{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/cactus-dark/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","path":"images/apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","path":"images/favicon-192x192.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/logo1.png","path":"images/logo1.png","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","path":"lib/justified-gallery/jquery.justifiedGallery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","path":"lib/justified-gallery/justifiedGallery.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","path":"lib/meslo-LG/styles.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","path":"lib/jquery/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Italic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGL-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGM-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","path":"lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","path":"lib/meslo-LG/fonts/MesloLGS-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/cactus-dark/source/images/theme overview.psd","path":"images/theme overview.psd","modified":1,"renderable":1}],"Cache":[{"_id":"themes/cactus-dark/_config.yml","hash":"540a217ef309e722b2dc4389c8b2bbb715961b76","modified":1494902010230},{"_id":"source/_data/projects.json","hash":"90949c6c55ad9c70a1a05d72996e8ad66352559e","modified":1494846647643},{"_id":"source/_posts/AMQP初探.md","hash":"b67b246b5a6d9b18e538409698c4062cb5887e5e","modified":1494849492647},{"_id":"source/_posts/Archipel的使用.md","hash":"ab2b1288efee2d48417bd552fcc54664562fce8d","modified":1494850548940},{"_id":"source/_posts/Mitaka认证的两种方式.md","hash":"643a333ef96fc16e4060baa767e9c591593db062","modified":1494849652737},{"_id":"source/_posts/RPC中的具体细节.md","hash":"4b26a7c8e21c682d9b4d2f8d055f9a2a0733840e","modified":1494850375906},{"_id":"source/_posts/RabbitMQ的RPC实现.md","hash":"38468771ef9581a72353c3109170ba6108ff51cc","modified":1494849353900},{"_id":"source/_posts/Ubuntu镜像制作.md","hash":"fa7f5e0dc4c1c77c80f2552ebac2d66a781f75f6","modified":1494850633079},{"_id":"source/_posts/使用Guestfish给虚拟磁盘扩容.md","hash":"aa5a1fc9796bdecf2dad1a0c93bd262ff88878cf","modified":1494850683364},{"_id":"source/_posts/安装与配置.md","hash":"ba1546bbdc8aded95dc6ce4de9ec8dce06cac86b","modified":1494850489908},{"_id":"source/_posts/扩展Compute节点.md","hash":"1a00372f815a1c83c946708e3fcdd0ea48567a6f","modified":1494850015914},{"_id":"source/_posts/父进程如何捕获子进程的异常？.md","hash":"5db5ecdb195e34252f9d66cbad3dce97c3f70f83","modified":1494850007389},{"_id":"themes/cactus-dark/layout/archive.ejs","hash":"ab9798bf534485a4fed4d3089011421858afdd26","modified":1494831154887},{"_id":"themes/cactus-dark/layout/index.ejs","hash":"53196279a25035da55902f4b8f0ebdf7871d39d1","modified":1494831154887},{"_id":"themes/cactus-dark/layout/layout.ejs","hash":"8484532ad7c4da22f46fc1394bb2fd9ded34be1f","modified":1494831154887},{"_id":"themes/cactus-dark/layout/page.ejs","hash":"b6b7b1e6dc856a0e62f35da0151f67ba41143e04","modified":1494831154887},{"_id":"themes/cactus-dark/layout/post.ejs","hash":"2731e597b5d1714a6f5a775c432e99785f02a3e3","modified":1494851046101},{"_id":"themes/cactus-dark/scripts/meta.js","hash":"fa6055a39851c9953d033e70c1614547b94dce60","modified":1494831154887},{"_id":"themes/cactus-dark/scripts/thumbnail.js","hash":"df8829fd8c3119650037eba5ec11bdce06acff9d","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/comments.ejs","hash":"853a4500da515ef3facc51a055886eaf8efd080d","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/footer.ejs","hash":"7f6b3f126a58e6734b658ab57bc6b41822bc9342","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/head.ejs","hash":"7782e6b1ce72fcf121f0017d383e2fb87e72c539","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/header.ejs","hash":"889fe54bbfd1fb3357e8c0614d57a437a72f782a","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/pagination.ejs","hash":"ca660c59aec56daa4a7b41715b97434d4a24c37e","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/scripts.ejs","hash":"6cffa3adb2f5b93a47f29549ac589c8bce8c223e","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/styles.ejs","hash":"e62b799d8ac369d1f1b36bd2649ecc34aec3384c","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_extend.styl","hash":"faca25132d55e8989d1c1d638e55d1e97de3c561","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_mixins.styl","hash":"c921ceb620deedddd38c9cec28190995e8764bab","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_util.styl","hash":"f8e286a21c7ec3e771d5ddeb2909ac92390af9bd","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_variables.styl","hash":"80345f77f0e601669047cbb3c44491720c3b5c13","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/style.styl","hash":"ad9a4185cf06a21aeeb40c2126aa8525a9aa46e4","modified":1494851262588},{"_id":"themes/cactus-dark/source/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1494831154887},{"_id":"themes/cactus-dark/source/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1494831154887},{"_id":"themes/cactus-dark/source/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1494831154891},{"_id":"themes/cactus-dark/source/images/logo.png","hash":"259f4c37fcdbc9788cb61f7df200f54e1ee5e469","modified":1494901874067},{"_id":"themes/cactus-dark/source/images/logo1.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1494831154891},{"_id":"themes/cactus-dark/source/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1494831154919},{"_id":"themes/cactus-dark/layout/_partial/post/actions_desktop.ejs","hash":"2319dea76f205c27dd59c994921f66350df8027a","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/actions_mobile.ejs","hash":"e7638a83e5aaa4bf5b24440ca76fec8eb563bed7","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/date.ejs","hash":"12a4a7ba6334e3e5c03d9a9601d7779a27c2e082","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/gallery.ejs","hash":"9aecd8908e8a684f33dc20c02497c0f1774137c7","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/share.ejs","hash":"25a3406f97e976ec13239f0d3f32f9e512511f50","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/tag.ejs","hash":"bfab03ef986d35ccad583f2d2b575db4a8d2789e","modified":1494831154887},{"_id":"themes/cactus-dark/layout/_partial/post/title.ejs","hash":"a060f1c6e3718494a6b1d0e1981ea0bf4e549828","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/agate.styl","hash":"601eb70448a16b918df132f6fc41e891ae053653","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/androidstudio.styl","hash":"65d09f1b0e81c6a182f549fd3de51e59823c97ae","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/arta.styl","hash":"1a5accc115f41d1b669ed708ac6a29abac876599","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-cave-dark.styl","hash":"bc647b2c1d971d7cc947aa1ed66e9fd115261921","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-dune-dark.styl","hash":"df50a85a4b14c7ca6e825d665594b91229d0e460","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-estuary-dark.styl","hash":"d84382bc8298f96730757391d3e761b7e640f406","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-forest-dark.styl","hash":"57c154c6045a038dc7df0a25927853e10bf48c4a","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-heath-dark.styl","hash":"b0cf13b2233e7bc38342032d2d7296591a4c2bcf","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-lakeside-dark.styl","hash":"bb0a8c4ad0dd8e3e7de7122ddf268fc42aa94acb","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-plateau-dark.styl","hash":"09c64f1a7052aec9070c36c0431df25216afaea1","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-savanna-dark.styl","hash":"a16c919a1ccf2f845488078fb341381bec46b1f3","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/dark.styl","hash":"71ce56d311cc2f3a605f6e2c495ccd7236878404","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/darkula.styl","hash":"ad0d5728d21645039c9f199e7a56814170ed3bab","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/far.styl","hash":"d9928010ffe71e80b97a5afcba1a4975efdd7372","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/hopscotch.styl","hash":"b374c6550b89b4751aedc8fbc3cf98d95bd70ead","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/hybrid.styl","hash":"ea8d7ddc258b073308746385f5cb85aabb8bfb83","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/ir-black.styl","hash":"693078bbd72a2091ed30f506cc55949600b717af","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/kimbie.styl","hash":"45dbb168f22d739d0109745d2decd66b5f94e786","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/monokai-sublime.styl","hash":"25aa2fc1dbe38593e7c7ebe525438a39574d9935","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/monokai.styl","hash":"5a4fe9f957fd7a368c21b62a818403db4270452f","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/obsidian.styl","hash":"55572bbcfee1de6c31ac54681bb00336f5ae826d","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/paraiso.styl","hash":"f1537bd868579fa018ecdbfd2eb922dcf3ba2cac","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/pojoaque.styl","hash":"77dae9dc41945359d17fe84dbd317f1b40b2ee33","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/railscasts.styl","hash":"acd620f8bb7ff0e3fe5f9a22b4433ceef93a05e6","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/rainbow.styl","hash":"ce73b858fc0aba0e57ef9fb136c083082746bc1d","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/solarized-dark.styl","hash":"702b9299a48c90124e3ac1d45f1591042f2beccc","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/sunburst.styl","hash":"a0b5b5129547a23865d400cfa562ea0ac1ee3958","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-blue.styl","hash":"8b3087d4422be6eb800935a22eb11e035341c4ba","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-bright.styl","hash":"0ac6af6ecb446b5b60d6226748e4a6532db34f57","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night-eighties.styl","hash":"fa57b3bb7857a160fc856dbe319b31e30cc5d771","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/tomorrow-night.styl","hash":"19b3080d4b066b40d50d7e7f297472482b5801fd","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/zenburn.styl","hash":"fc5ec840435dad80964d04519d3f882ddc03746a","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/archive.styl","hash":"18fa7f84a9783c5fb56c9f450ea93bd88408e682","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/article.styl","hash":"202b775a966d7bc35bf5adc693b62463dec106bb","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/comments.styl","hash":"11fb41241a13971d23fc3f7e6d60315c7f248396","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/footer.styl","hash":"b7570de60eaf9aa6b0192bf9c71b9172ff11bfbc","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/header.styl","hash":"63707d9103a283147ca222fd6f8ff9bffbffe427","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/index.styl","hash":"cf43702450ea1e5617541501886982a394cff8ec","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/pagination.styl","hash":"03a1b81d60dae3dd55963b7e74a6fee83470e6bb","modified":1494831154887},{"_id":"themes/cactus-dark/source/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1494831154939},{"_id":"themes/cactus-dark/source/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1494831154939},{"_id":"themes/cactus-dark/source/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1494831154967},{"_id":"themes/cactus-dark/source/css/_highlight/codepen-embed.styl","hash":"f4dcc84d8e39f9831a5efe80e51923fc3054feb0","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-sulphurpool-dark.styl","hash":"414b0cfc142f70afe359c16450b651e28bf7325a","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_highlight/atelier-seaside-dark.styl","hash":"ce233a101daea7124cbfcd34add43ccfe2e1e1c7","modified":1494831154887},{"_id":"themes/cactus-dark/source/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1494831154939},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_desktop.styl","hash":"a9f9b6382d313f9ef9ff9f53bd0db11e5b36edf4","modified":1494831154887},{"_id":"themes/cactus-dark/source/css/_partial/post/actions_mobile.styl","hash":"e6a802d7ee1023c5fc5fac18bb0ba3dc03ef2ac8","modified":1494831154887},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1494831154923},{"_id":"themes/cactus-dark/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1494831154923},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1494831154935},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1494831154935},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1494831154927},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1494831154927},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1494831154935},{"_id":"themes/cactus-dark/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1494831154935},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1494831154951},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1494831154967},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1494831154967},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1494831154943},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1494831154947},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1494831154955},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1494831154955},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1494831154963},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1494831154967},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1494831154967},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1494831154967},{"_id":"themes/cactus-dark/source/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1494831154967},{"_id":"themes/cactus-dark/source/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1494831154919},{"_id":"public/2016/12/03/Ubuntu镜像制作/index.html","hash":"5e250874a04858cab162a8cbaeb43eaddd6ee305","modified":1494902039192},{"_id":"public/archives/index.html","hash":"6f2c407ba2f6b2318459faba08b35707b8583f01","modified":1494902039192},{"_id":"public/archives/2016/index.html","hash":"e9a923b8ab97fee9b534677ae0813df2e99ac998","modified":1494902039193},{"_id":"public/archives/2016/01/index.html","hash":"90f399e67bff71840ac664f63655c6c2d02aa317","modified":1494902039193},{"_id":"public/archives/2016/04/index.html","hash":"e751cc88c6dd8f3aca2289f76cfab6dc585293cf","modified":1494902039193},{"_id":"public/archives/2016/05/index.html","hash":"4d6cb6c4a93e3aad813d203b3752b7c0d22d6eeb","modified":1494902039194},{"_id":"public/archives/2016/06/index.html","hash":"79e95ac526a013a71c67e0d8aa25778b0e7fb932","modified":1494902039194},{"_id":"public/archives/2016/07/index.html","hash":"ed754acd31b871326cb3295e1d7cad12dce9f348","modified":1494902039194},{"_id":"public/archives/2016/08/index.html","hash":"7f94a14aec319de0a1fd523e0d0fb9663621aed4","modified":1494902039194},{"_id":"public/archives/2016/09/index.html","hash":"45a8987877091ad1fb13103ed10b72b885e7f0e0","modified":1494902039194},{"_id":"public/archives/2016/10/index.html","hash":"d08db3400bcea156436ce58785bf917912ca9696","modified":1494902039194},{"_id":"public/archives/2016/12/index.html","hash":"d8abc34db471160e21078dd03daae228463030c2","modified":1494902039194},{"_id":"public/index.html","hash":"3f46309d610f986d57a8a61b33108eedad60dcc5","modified":1494902039195},{"_id":"public/tags/AMQP/index.html","hash":"b168cd9ecaf0d136248490c55f2bc2f454fa3b85","modified":1494902039195},{"_id":"public/tags/Archipel/index.html","hash":"50fea6f7982172af44682424cdf1dfaeed98f05f","modified":1494902039195},{"_id":"public/tags/OpenStack/index.html","hash":"75f113e7050cf15d864ab0558a6387f16a16a0c9","modified":1494902039195},{"_id":"public/tags/RPC/index.html","hash":"73298a9e40471ef089e87132094929463f34202f","modified":1494902039195},{"_id":"public/tags/RabbitMQ/index.html","hash":"289b6a92642837098400dbeaea0fb09b1f797cfc","modified":1494902039195},{"_id":"public/tags/Linux/index.html","hash":"833ac09e634372defc76c87b4dcf06305406d144","modified":1494902039195},{"_id":"public/tags/GuestFish/index.html","hash":"3707ad2f4a8467f1dd4f413bec76303a77837842","modified":1494902039196},{"_id":"public/tags/Python/index.html","hash":"72b1444406b07795c60ba7c2f11cccc67328dc01","modified":1494902039197},{"_id":"public/2016/10/11/使用Guestfish给虚拟磁盘扩容/index.html","hash":"8c391def54e3dbe14d85cf52455a7016ef978d62","modified":1494902039197},{"_id":"public/2016/09/20/扩展Compute节点/index.html","hash":"ac0681aef1eea3e2af5ba42fb72e84dfa8ee9053","modified":1494902039198},{"_id":"public/2016/08/15/父进程如何捕获子进程的异常？/index.html","hash":"c791564378b4bd21eb57d54a75d310ed7a6d89b5","modified":1494902039198},{"_id":"public/2016/07/22/RPC中的具体细节/index.html","hash":"234fe0745997b1101653af175f16cda9074425bb","modified":1494902039198},{"_id":"public/2016/06/16/AMQP初探/index.html","hash":"934b35b852a271c01c11ae05381e4e0bc40949ae","modified":1494902039198},{"_id":"public/2016/05/01/RabbitMQ的RPC实现/index.html","hash":"0bc76c75175f4164166265d7de1e29854b87cce1","modified":1494902039199},{"_id":"public/2016/04/05/Mitaka认证的两种方式/index.html","hash":"69ad284e0728a293309bf0526f963081f2d75f66","modified":1494902039199},{"_id":"public/2016/01/27/Archipel的使用/index.html","hash":"cb4d97c8956ed4c08695ac5d64692fa2be164cc7","modified":1494902039199},{"_id":"public/2016/01/26/安装与配置/index.html","hash":"e34e7b4e5e63e6be99e3bf6e95324138d1dbf897","modified":1494902039199},{"_id":"public/images/apple-touch-icon.png","hash":"57e2def34682655f41a0be2d083f16765ba7858b","modified":1494902039212},{"_id":"public/images/favicon-192x192.png","hash":"96e6fcbbb13a5914a6131391e210eb7dfd13d692","modified":1494902039212},{"_id":"public/images/favicon.ico","hash":"189f9842bcb79a6f8f9e8445bc8bbd773443826b","modified":1494902039212},{"_id":"public/images/logo.png","hash":"259f4c37fcdbc9788cb61f7df200f54e1ee5e469","modified":1494902039212},{"_id":"public/images/logo1.png","hash":"199750f3a39251ca97d36ed8317d88dfdc2dfe66","modified":1494902039212},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1494902039653},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1494902039655},{"_id":"public/js/main.js","hash":"2703a7cb4fc7056d13215b9fde675da426b9cdc4","modified":1494902039662},{"_id":"public/lib/justified-gallery/justifiedGallery.min.css","hash":"13fbcba5e97aa88b748d94d3efc4718475279907","modified":1494902039662},{"_id":"public/lib/meslo-LG/styles.css","hash":"eb88d0b9f1bbef99070e9627e2c96d892036bf7e","modified":1494902039662},{"_id":"public/css/style.css","hash":"b3ee4af280837a60ccc83475b83dca41f6426a06","modified":1494902039662},{"_id":"public/lib/justified-gallery/jquery.justifiedGallery.min.js","hash":"b2683e7a872bc109b1756a65188a37cef7d0bd5c","modified":1494902039662},{"_id":"public/lib/jquery/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1494902039663},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1494902039663},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1494902039663},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1494902039663},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1494902039663},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1494902039663},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1494902039684},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Italic.ttf","hash":"96c97a0a098ca40802f948ae56fa37aa6683d034","modified":1494902039696},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Italic.ttf","hash":"68700db02debd4b922304134da83b829cbfddfc9","modified":1494902039696},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Italic.ttf","hash":"7f7cdbdcc26279c04046632e22d872f111bc9399","modified":1494902039697},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Bold.ttf","hash":"bfa1ed9a263ed78462f06d322de13bd5bd0906b2","modified":1494902039704},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-BoldItalic.ttf","hash":"a9a431fc7a6c3a67c98021d4035c12a07a4f1070","modified":1494902039704},{"_id":"public/lib/meslo-LG/fonts/MesloLGL-Regular.ttf","hash":"2b912dd13f052f645ee19951604610bb350d50af","modified":1494902039704},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Bold.ttf","hash":"a8a8df3393bccc365335fc5eb0a62a6b7ccd32b9","modified":1494902039705},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-BoldItalic.ttf","hash":"65ddb11e75ee93909e845ab912a36717c48f1c94","modified":1494902039706},{"_id":"public/lib/meslo-LG/fonts/MesloLGM-Regular.ttf","hash":"5e220152adefe905b2197f873d7cee99eca50e91","modified":1494902039706},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Bold.ttf","hash":"df202ce09cbdc70bc16b81983a13ef0f94e46f10","modified":1494902039707},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-BoldItalic.ttf","hash":"d895a1bd25e36c58b7f463ebe14de09f186d5ab4","modified":1494902039707},{"_id":"public/lib/meslo-LG/fonts/MesloLGS-Regular.ttf","hash":"56fa0e33a390b704afc56af93a31576ccdbbdd9e","modified":1494902039709},{"_id":"public/images/theme overview.psd","hash":"8dc11d9d289c247423911e962c4eb3a556dc67d1","modified":1494902039765}],"Category":[],"Data":[{"_id":"projects","data":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}],"Page":[],"Post":[{"title":"AMQP初探","date":"2016-06-16T11:57:21.000Z","_content":"\n## AMQP是什么\n AMQP 全称为( Advanced Message Queuing Protocol), 它是一个跨平台的提供统一消息服务的应用层标准协议，它允许来自不同供应商的生产以及消费者之前的 相互通信，因此，基于AMQP协议开发的客户端与消息中间件之前的通信并不受供应商，开发语言等条件的限制。 \n\n 基于AMQP协议的常见消息中间件有QPID、RabbitMQ、ActiveMQ等等。\n \n---------\n## 基本概念\n\n### 生产者 Producer\n产生消息，并将消息递交给Exchange\n### 交换机 Exchange\n负责消息将正确地转发到相应的队列\n### 队列 Queue\n存储消息的容器(队列)，先进先出\n### 消费者 Consumer\n从队列中取出消息并进行处理\n### 路由键 `Routing_key`\n在生产者将消息发送到Exchange时需要用到的参数。\n> 该参数说明了**消息的属性**，换言之，说明了该消息是什么类型的消息。\n### 绑定键 `Binding_key`\n在交换机将生产者递送来的消息转发到与此交换机绑定的队列时，需要用到的参数。\n> 该参数说明了**队列的属性**，换言之，说明了该队列愿意接纳什么样类型的消息\n\n---------\n## 消息转发方式\n取决于交换机的类型，如下：\n### Direct型\n`单播型`： 在路由键和绑定键**完全匹配**的消息和队列之间建立转发通道\n### Fanout型\n`广播型`： 将消息和当前**所有队列**(和当前exchange建立绑定)之前建立转发通道\n### Topic 型\n`组播型` ： 路由键和绑定键是**模糊匹配**的，匹配规则如下：\n>格式： `<elem>.<color>.<specific>`\n>\n> `* ` : 匹配一个单词，表示该处必须有一个单词\n> \n>  `#` : 匹配任意个单词，表示该处有没有单词都行\n>  \n>  示例： 消息路由键为`*.color.#`将与队列绑定键为`parameter.color`或者`parameter.color.red`匹配 \n\n### Header 型\n>  Message是AMQP模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。\n\n所以，对于RabbitMQ，由于routing_key以及其他一些参数，充当了消息头的角色，故，RabbitMq中并未实现header    \n```python\n# send message\nmessage =  \"Hello World!\"\nchannel.basic_publish(exchange='',\n                  routing_key='color',\n                  body=message,\n                  properties=pika.BasicProperties(\n                     delivery_mode = 2, \n                      ))\n```\n","source":"_posts/AMQP初探.md","raw":"---\ntitle: AMQP初探\ndate: 2016-06-16 04:57:21\ntags:\n - AMQP\n---\n\n## AMQP是什么\n AMQP 全称为( Advanced Message Queuing Protocol), 它是一个跨平台的提供统一消息服务的应用层标准协议，它允许来自不同供应商的生产以及消费者之前的 相互通信，因此，基于AMQP协议开发的客户端与消息中间件之前的通信并不受供应商，开发语言等条件的限制。 \n\n 基于AMQP协议的常见消息中间件有QPID、RabbitMQ、ActiveMQ等等。\n \n---------\n## 基本概念\n\n### 生产者 Producer\n产生消息，并将消息递交给Exchange\n### 交换机 Exchange\n负责消息将正确地转发到相应的队列\n### 队列 Queue\n存储消息的容器(队列)，先进先出\n### 消费者 Consumer\n从队列中取出消息并进行处理\n### 路由键 `Routing_key`\n在生产者将消息发送到Exchange时需要用到的参数。\n> 该参数说明了**消息的属性**，换言之，说明了该消息是什么类型的消息。\n### 绑定键 `Binding_key`\n在交换机将生产者递送来的消息转发到与此交换机绑定的队列时，需要用到的参数。\n> 该参数说明了**队列的属性**，换言之，说明了该队列愿意接纳什么样类型的消息\n\n---------\n## 消息转发方式\n取决于交换机的类型，如下：\n### Direct型\n`单播型`： 在路由键和绑定键**完全匹配**的消息和队列之间建立转发通道\n### Fanout型\n`广播型`： 将消息和当前**所有队列**(和当前exchange建立绑定)之前建立转发通道\n### Topic 型\n`组播型` ： 路由键和绑定键是**模糊匹配**的，匹配规则如下：\n>格式： `<elem>.<color>.<specific>`\n>\n> `* ` : 匹配一个单词，表示该处必须有一个单词\n> \n>  `#` : 匹配任意个单词，表示该处有没有单词都行\n>  \n>  示例： 消息路由键为`*.color.#`将与队列绑定键为`parameter.color`或者`parameter.color.red`匹配 \n\n### Header 型\n>  Message是AMQP模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。\n\n所以，对于RabbitMQ，由于routing_key以及其他一些参数，充当了消息头的角色，故，RabbitMq中并未实现header    \n```python\n# send message\nmessage =  \"Hello World!\"\nchannel.basic_publish(exchange='',\n                  routing_key='color',\n                  body=message,\n                  properties=pika.BasicProperties(\n                     delivery_mode = 2, \n                      ))\n```\n","slug":"AMQP初探","published":1,"updated":"2017-05-15T11:58:12.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r010000mqjxfju6ttgb","content":"<h2 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h2><p> AMQP 全称为( Advanced Message Queuing Protocol), 它是一个跨平台的提供统一消息服务的应用层标准协议，它允许来自不同供应商的生产以及消费者之前的 相互通信，因此，基于AMQP协议开发的客户端与消息中间件之前的通信并不受供应商，开发语言等条件的限制。 </p>\n<p> 基于AMQP协议的常见消息中间件有QPID、RabbitMQ、ActiveMQ等等。</p>\n<hr>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"生产者-Producer\"><a href=\"#生产者-Producer\" class=\"headerlink\" title=\"生产者 Producer\"></a>生产者 Producer</h3><p>产生消息，并将消息递交给Exchange</p>\n<h3 id=\"交换机-Exchange\"><a href=\"#交换机-Exchange\" class=\"headerlink\" title=\"交换机 Exchange\"></a>交换机 Exchange</h3><p>负责消息将正确地转发到相应的队列</p>\n<h3 id=\"队列-Queue\"><a href=\"#队列-Queue\" class=\"headerlink\" title=\"队列 Queue\"></a>队列 Queue</h3><p>存储消息的容器(队列)，先进先出</p>\n<h3 id=\"消费者-Consumer\"><a href=\"#消费者-Consumer\" class=\"headerlink\" title=\"消费者 Consumer\"></a>消费者 Consumer</h3><p>从队列中取出消息并进行处理</p>\n<h3 id=\"路由键-Routing-key\"><a href=\"#路由键-Routing-key\" class=\"headerlink\" title=\"路由键 Routing_key\"></a>路由键 <code>Routing_key</code></h3><p>在生产者将消息发送到Exchange时需要用到的参数。</p>\n<blockquote>\n<p>该参数说明了<strong>消息的属性</strong>，换言之，说明了该消息是什么类型的消息。</p>\n<h3 id=\"绑定键-Binding-key\"><a href=\"#绑定键-Binding-key\" class=\"headerlink\" title=\"绑定键 Binding_key\"></a>绑定键 <code>Binding_key</code></h3><p>在交换机将生产者递送来的消息转发到与此交换机绑定的队列时，需要用到的参数。<br>该参数说明了<strong>队列的属性</strong>，换言之，说明了该队列愿意接纳什么样类型的消息</p>\n</blockquote>\n<hr>\n<h2 id=\"消息转发方式\"><a href=\"#消息转发方式\" class=\"headerlink\" title=\"消息转发方式\"></a>消息转发方式</h2><p>取决于交换机的类型，如下：</p>\n<h3 id=\"Direct型\"><a href=\"#Direct型\" class=\"headerlink\" title=\"Direct型\"></a>Direct型</h3><p><code>单播型</code>： 在路由键和绑定键<strong>完全匹配</strong>的消息和队列之间建立转发通道</p>\n<h3 id=\"Fanout型\"><a href=\"#Fanout型\" class=\"headerlink\" title=\"Fanout型\"></a>Fanout型</h3><p><code>广播型</code>： 将消息和当前<strong>所有队列</strong>(和当前exchange建立绑定)之前建立转发通道</p>\n<h3 id=\"Topic-型\"><a href=\"#Topic-型\" class=\"headerlink\" title=\"Topic 型\"></a>Topic 型</h3><p><code>组播型</code> ： 路由键和绑定键是<strong>模糊匹配</strong>的，匹配规则如下：</p>\n<blockquote>\n<p>格式： <code>&lt;elem&gt;.&lt;color&gt;.&lt;specific&gt;</code></p>\n<p><code>*</code> : 匹配一个单词，表示该处必须有一个单词</p>\n<p> <code>#</code> : 匹配任意个单词，表示该处有没有单词都行</p>\n<p> 示例： 消息路由键为<code>*.color.#</code>将与队列绑定键为<code>parameter.color</code>或者<code>parameter.color.red</code>匹配 </p>\n</blockquote>\n<h3 id=\"Header-型\"><a href=\"#Header-型\" class=\"headerlink\" title=\"Header 型\"></a>Header 型</h3><blockquote>\n<p> Message是AMQP模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。</p>\n</blockquote>\n<p>所以，对于RabbitMQ，由于routing_key以及其他一些参数，充当了消息头的角色，故，RabbitMq中并未实现header<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># send message</span></div><div class=\"line\">message =  <span class=\"string\">\"Hello World!\"</span></div><div class=\"line\">channel.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                  routing_key=<span class=\"string\">'color'</span>,</div><div class=\"line\">                  body=message,</div><div class=\"line\">                  properties=pika.BasicProperties(</div><div class=\"line\">                     delivery_mode = <span class=\"number\">2</span>, </div><div class=\"line\">                      ))</div></pre></td></tr></table></figure></p>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h2 id=\"AMQP是什么\"><a href=\"#AMQP是什么\" class=\"headerlink\" title=\"AMQP是什么\"></a>AMQP是什么</h2><p> AMQP 全称为( Advanced Message Queuing Protocol), 它是一个跨平台的提供统一消息服务的应用层标准协议，它允许来自不同供应商的生产以及消费者之前的 相互通信，因此，基于AMQP协议开发的客户端与消息中间件之前的通信并不受供应商，开发语言等条件的限制。 </p>\n<p> 基于AMQP协议的常见消息中间件有QPID、RabbitMQ、ActiveMQ等等。</p>\n<hr>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"生产者-Producer\"><a href=\"#生产者-Producer\" class=\"headerlink\" title=\"生产者 Producer\"></a>生产者 Producer</h3><p>产生消息，并将消息递交给Exchange</p>\n<h3 id=\"交换机-Exchange\"><a href=\"#交换机-Exchange\" class=\"headerlink\" title=\"交换机 Exchange\"></a>交换机 Exchange</h3><p>负责消息将正确地转发到相应的队列</p>\n<h3 id=\"队列-Queue\"><a href=\"#队列-Queue\" class=\"headerlink\" title=\"队列 Queue\"></a>队列 Queue</h3><p>存储消息的容器(队列)，先进先出</p>\n<h3 id=\"消费者-Consumer\"><a href=\"#消费者-Consumer\" class=\"headerlink\" title=\"消费者 Consumer\"></a>消费者 Consumer</h3><p>从队列中取出消息并进行处理</p>\n<h3 id=\"路由键-Routing-key\"><a href=\"#路由键-Routing-key\" class=\"headerlink\" title=\"路由键 Routing_key\"></a>路由键 <code>Routing_key</code></h3><p>在生产者将消息发送到Exchange时需要用到的参数。</p>\n<blockquote>\n<p>该参数说明了<strong>消息的属性</strong>，换言之，说明了该消息是什么类型的消息。</p>\n<h3 id=\"绑定键-Binding-key\"><a href=\"#绑定键-Binding-key\" class=\"headerlink\" title=\"绑定键 Binding_key\"></a>绑定键 <code>Binding_key</code></h3><p>在交换机将生产者递送来的消息转发到与此交换机绑定的队列时，需要用到的参数。<br>该参数说明了<strong>队列的属性</strong>，换言之，说明了该队列愿意接纳什么样类型的消息</p>\n</blockquote>\n<hr>\n<h2 id=\"消息转发方式\"><a href=\"#消息转发方式\" class=\"headerlink\" title=\"消息转发方式\"></a>消息转发方式</h2><p>取决于交换机的类型，如下：</p>\n<h3 id=\"Direct型\"><a href=\"#Direct型\" class=\"headerlink\" title=\"Direct型\"></a>Direct型</h3><p><code>单播型</code>： 在路由键和绑定键<strong>完全匹配</strong>的消息和队列之间建立转发通道</p>\n<h3 id=\"Fanout型\"><a href=\"#Fanout型\" class=\"headerlink\" title=\"Fanout型\"></a>Fanout型</h3><p><code>广播型</code>： 将消息和当前<strong>所有队列</strong>(和当前exchange建立绑定)之前建立转发通道</p>\n<h3 id=\"Topic-型\"><a href=\"#Topic-型\" class=\"headerlink\" title=\"Topic 型\"></a>Topic 型</h3><p><code>组播型</code> ： 路由键和绑定键是<strong>模糊匹配</strong>的，匹配规则如下：</p>\n<blockquote>\n<p>格式： <code>&lt;elem&gt;.&lt;color&gt;.&lt;specific&gt;</code></p>\n<p><code>*</code> : 匹配一个单词，表示该处必须有一个单词</p>\n<p> <code>#</code> : 匹配任意个单词，表示该处有没有单词都行</p>\n<p> 示例： 消息路由键为<code>*.color.#</code>将与队列绑定键为<code>parameter.color</code>或者<code>parameter.color.red</code>匹配 </p>\n</blockquote>\n<h3 id=\"Header-型\"><a href=\"#Header-型\" class=\"headerlink\" title=\"Header 型\"></a>Header 型</h3><blockquote>\n<p> Message是AMQP模型中所操纵的基本单位，它由Producer产生，经过Broker被Consumer所消费。它的基本结构有两部分: Header和Body。Header是由Producer添加上的各种属性的集合，这些属性有控制Message是否可被缓存，接收的queue是哪个，优先级是多少等。</p>\n</blockquote>\n<p>所以，对于RabbitMQ，由于routing_key以及其他一些参数，充当了消息头的角色，故，RabbitMq中并未实现header<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># send message</span></div><div class=\"line\">message =  <span class=\"string\">\"Hello World!\"</span></div><div class=\"line\">channel.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                  routing_key=<span class=\"string\">'color'</span>,</div><div class=\"line\">                  body=message,</div><div class=\"line\">                  properties=pika.BasicProperties(</div><div class=\"line\">                     delivery_mode = <span class=\"number\">2</span>, </div><div class=\"line\">                      ))</div></pre></td></tr></table></figure></p>\n"},{"title":"Archipel的使用","date":"2016-01-27T13:15:09.000Z","_content":"\n在我的上一篇文章之后，现在你的Archipel GUI应该如下：\n\n![Ａｒｃｈｉｐｅｌ](http://upload-images.jianshu.io/upload_images/1113810-5b7ef3fe012172a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如图有两个主要联系人（无视分组），那是两台物理机。在上一篇文章的基础上，我另添加了一台服务器。\n\n#####左边联系人框\n        在这里，你可以看到所有的物理机以及运行在其上的虚拟机。当然，最好分好组，方便管理，分组方法\\\n    ，就是左下的“＋”号，点击添加Group\n ![联系人](http://upload-images.jianshu.io/upload_images/1113810-fc543a3b26f17f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#####物理机\n    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n\n    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n            曲线。\n    Virtual Machines: 在这里,你可以看到该物理机下所有的虚拟机,Archipel VMs指的是已经让Archipel\n                      接管的虚拟机，Other VMs指的是未让Archipel接管的虚拟机，你可以在此窗口,对\n                      虚拟机做出调整。 左下的“＋”号可以创建虚拟机，但要事先把相应的ISO文件放进指定\n                      目录，该目录默认/vm/iso,需要事先创建，并给予777权限。\n    NetWorks：显示该物理机的网络信息\n    VMCasts：暂未测试，稍后更新\n    Scheduler：设定一系列命令，命令会在你设定的时间执行\n    Chat：与其进行交互，如下，更多交互方式查看官网\n\n![Chat](http://upload-images.jianshu.io/upload_images/1113810-a8fb10a5b8dc0655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n    之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台物理机的\n    操作权限。\n\n#####虚拟机:\n    Controls：这里进行一些虚拟机的基本控制\n    Definition：在虚拟机关机状态下，设置虚拟机的属性，当然你也可以点击中间下边的“</>”按钮来直\n                接编辑该虚拟机的xml文档，编辑完成后点击“define”即可生效，该按钮旁边的按钮功\n                能是“undefine the vm”。\n    Appliances：稍后更新\n    Disks：编辑Disk文件等等\n    Snapshots：在这里，拍摄快照，编辑快照等等\n    VNC Console：如下图，相当于一个vnc screen\n\n![选区_004.png](http://upload-images.jianshu.io/upload_images/1113810-037db50a50b5e10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    Scheduler：设定一系列命令，命令会在你设定的时间执行\n    Chat：与其进行交互\n    Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n    之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台虚拟机的\n    操作权限。\n\n\n######注：页面头像右边的控制按钮时用来控制虚拟机的\n","source":"_posts/Archipel的使用.md","raw":"---\ntitle: Archipel的使用\ndate: 2016-01-27 05:15:09\ntags:\n - Archipel\n---\n\n在我的上一篇文章之后，现在你的Archipel GUI应该如下：\n\n![Ａｒｃｈｉｐｅｌ](http://upload-images.jianshu.io/upload_images/1113810-5b7ef3fe012172a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n如图有两个主要联系人（无视分组），那是两台物理机。在上一篇文章的基础上，我另添加了一台服务器。\n\n#####左边联系人框\n        在这里，你可以看到所有的物理机以及运行在其上的虚拟机。当然，最好分好组，方便管理，分组方法\\\n    ，就是左下的“＋”号，点击添加Group\n ![联系人](http://upload-images.jianshu.io/upload_images/1113810-fc543a3b26f17f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#####物理机\n    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n\n    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n            曲线。\n    Virtual Machines: 在这里,你可以看到该物理机下所有的虚拟机,Archipel VMs指的是已经让Archipel\n                      接管的虚拟机，Other VMs指的是未让Archipel接管的虚拟机，你可以在此窗口,对\n                      虚拟机做出调整。 左下的“＋”号可以创建虚拟机，但要事先把相应的ISO文件放进指定\n                      目录，该目录默认/vm/iso,需要事先创建，并给予777权限。\n    NetWorks：显示该物理机的网络信息\n    VMCasts：暂未测试，稍后更新\n    Scheduler：设定一系列命令，命令会在你设定的时间执行\n    Chat：与其进行交互，如下，更多交互方式查看官网\n\n![Chat](http://upload-images.jianshu.io/upload_images/1113810-a8fb10a5b8dc0655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n    之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台物理机的\n    操作权限。\n\n#####虚拟机:\n    Controls：这里进行一些虚拟机的基本控制\n    Definition：在虚拟机关机状态下，设置虚拟机的属性，当然你也可以点击中间下边的“</>”按钮来直\n                接编辑该虚拟机的xml文档，编辑完成后点击“define”即可生效，该按钮旁边的按钮功\n                能是“undefine the vm”。\n    Appliances：稍后更新\n    Disks：编辑Disk文件等等\n    Snapshots：在这里，拍摄快照，编辑快照等等\n    VNC Console：如下图，相当于一个vnc screen\n\n![选区_004.png](http://upload-images.jianshu.io/upload_images/1113810-037db50a50b5e10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n    Scheduler：设定一系列命令，命令会在你设定的时间执行\n    Chat：与其进行交互\n    Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n    之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台虚拟机的\n    操作权限。\n\n\n######注：页面头像右边的控制按钮时用来控制虚拟机的\n","slug":"Archipel的使用","published":1,"updated":"2017-05-15T12:15:48.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r080001mqjx6di02rf7","content":"<p>在我的上一篇文章之后，现在你的Archipel GUI应该如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-5b7ef3fe012172a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Ａｒｃｈｉｐｅｌ\"></p>\n<p>如图有两个主要联系人（无视分组），那是两台物理机。在上一篇文章的基础上，我另添加了一台服务器。</p>\n<p>#####左边联系人框<br>        在这里，你可以看到所有的物理机以及运行在其上的虚拟机。当然，最好分好组，方便管理，分组方法\\<br>    ，就是左下的“＋”号，点击添加Group<br> <img src=\"http://upload-images.jianshu.io/upload_images/1113810-fc543a3b26f17f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"联系人\"></p>\n<p>#####物理机<br>    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作</p>\n<pre><code>Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n        曲线。\nVirtual Machines: 在这里,你可以看到该物理机下所有的虚拟机,Archipel VMs指的是已经让Archipel\n                  接管的虚拟机，Other VMs指的是未让Archipel接管的虚拟机，你可以在此窗口,对\n                  虚拟机做出调整。 左下的“＋”号可以创建虚拟机，但要事先把相应的ISO文件放进指定\n                  目录，该目录默认/vm/iso,需要事先创建，并给予777权限。\nNetWorks：显示该物理机的网络信息\nVMCasts：暂未测试，稍后更新\nScheduler：设定一系列命令，命令会在你设定的时间执行\nChat：与其进行交互，如下，更多交互方式查看官网\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-a8fb10a5b8dc0655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chat\"></p>\n<pre><code>Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台物理机的\n操作权限。\n</code></pre><p>#####虚拟机:<br>    Controls：这里进行一些虚拟机的基本控制<br>    Definition：在虚拟机关机状态下，设置虚拟机的属性，当然你也可以点击中间下边的“&lt;/&gt;”按钮来直<br>                接编辑该虚拟机的xml文档，编辑完成后点击“define”即可生效，该按钮旁边的按钮功<br>                能是“undefine the vm”。<br>    Appliances：稍后更新<br>    Disks：编辑Disk文件等等<br>    Snapshots：在这里，拍摄快照，编辑快照等等<br>    VNC Console：如下图，相当于一个vnc screen</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-037db50a50b5e10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"选区_004.png\"></p>\n<pre><code>Scheduler：设定一系列命令，命令会在你设定的时间执行\nChat：与其进行交互\nPermissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台虚拟机的\n操作权限。\n</code></pre><p>######注：页面头像右边的控制按钮时用来控制虚拟机的</p>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<p>在我的上一篇文章之后，现在你的Archipel GUI应该如下：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-5b7ef3fe012172a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Ａｒｃｈｉｐｅｌ\"></p>\n<p>如图有两个主要联系人（无视分组），那是两台物理机。在上一篇文章的基础上，我另添加了一台服务器。</p>\n<p>#####左边联系人框<br>        在这里，你可以看到所有的物理机以及运行在其上的虚拟机。当然，最好分好组，方便管理，分组方法\\<br>    ，就是左下的“＋”号，点击添加Group<br> <img src=\"http://upload-images.jianshu.io/upload_images/1113810-fc543a3b26f17f04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"联系人\"></p>\n<p>#####物理机<br>    Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作</p>\n<pre><code>Health: 选中一个物理机，中间大窗口会显示物理机此时的Health, 以及实时的CPU、Disk、NetWork工作\n        曲线。\nVirtual Machines: 在这里,你可以看到该物理机下所有的虚拟机,Archipel VMs指的是已经让Archipel\n                  接管的虚拟机，Other VMs指的是未让Archipel接管的虚拟机，你可以在此窗口,对\n                  虚拟机做出调整。 左下的“＋”号可以创建虚拟机，但要事先把相应的ISO文件放进指定\n                  目录，该目录默认/vm/iso,需要事先创建，并给予777权限。\nNetWorks：显示该物理机的网络信息\nVMCasts：暂未测试，稍后更新\nScheduler：设定一系列命令，命令会在你设定的时间执行\nChat：与其进行交互，如下，更多交互方式查看官网\n</code></pre><p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-a8fb10a5b8dc0655.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chat\"></p>\n<pre><code>Permissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台物理机的\n操作权限。\n</code></pre><p>#####虚拟机:<br>    Controls：这里进行一些虚拟机的基本控制<br>    Definition：在虚拟机关机状态下，设置虚拟机的属性，当然你也可以点击中间下边的“&lt;/&gt;”按钮来直<br>                接编辑该虚拟机的xml文档，编辑完成后点击“define”即可生效，该按钮旁边的按钮功<br>                能是“undefine the vm”。<br>    Appliances：稍后更新<br>    Disks：编辑Disk文件等等<br>    Snapshots：在这里，拍摄快照，编辑快照等等<br>    VNC Console：如下图，相当于一个vnc screen</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-037db50a50b5e10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"选区_004.png\"></p>\n<pre><code>Scheduler：设定一系列命令，命令会在你设定的时间执行\nChat：与其进行交互\nPermissions：Archipel当然不是只有admin才能登陆，你可以在XMPP服务器上创建注册更多的用户，用户\n之间在Archipel也可以互相添加联系人。具有admin权限的用户，可以在这里调整其他用户对与某台虚拟机的\n操作权限。\n</code></pre><p>######注：页面头像右边的控制按钮时用来控制虚拟机的</p>\n"},{"layout":"获取openstack","title":"Mitaka认证的两种方式","date":"2016-04-05T11:56:12.000Z","_content":"\n## 背景\n    随着OpenStack不断发展, 目前的MITAKA版本的keystone已经弃用了第二版本的身份认证API, 而且我在M版本下使用原来版本的keystoneclient时, 发现提示如下\n    \n>  DeprecationWarning: keystoneclient auth plugins are deprecated as of the 2.1.0 release in favor of keystoneauth1 plugins. They will be removed in future releases.\n\n    因此, 在Mitaka版本中使用keystoneclient已不可取, 而且第三版的身份认证API和第二代有比较大的不同.\n\n-------------\n## Keystone第三版身份认证相关参数\n只涉及到\n>`project_domain`: 项目域\n>`project_name`:项目(租户)\n>`user_domain_name`:用户域\n>`username`:用户名\n>`password`:密码\n>`auth_url`:认证地址, \"**http://controller:5000/v3/**\"\n> region: 区域, Regions之间完全隔离，但它们共享同一个Keystone和Dashboard服务\n> auth_plugin: 认证方式, \"**password**\"\n>其中, 高亮部分为必须参数,其余为可选参数\n\n----------------\n## 在代码中直接指定相关参数\n\n```python\ndef create_connection(project_domain_name, user_domain_name, auth_url, region, project_name, username, password):\n    prof = profile.Profile()\n    prof.set_region(profile.Profile.ALL, region)\n\n    return connection.Connection(\n        profile=prof,\n        user_agent='Autumn',\n        project_domain_name=project_domain_name,\n        user_domain_name=user_domain_name,\n        auth_url=auth_url,\n        project_name=project_name,\n        username=username,\n        password=password\n    )\n\ndef list_images(conn):\n    print(\"List Images:\")\n\n    for image in conn.image.images():\n        print(image)\n\nif __name__ == '__main__':\n\n    auth_args = {\n        'project_domain_name':'default',\n        'user_domain_name':'default',\n        'auth_url': 'http://127.0.0.1:5000/v3',\n        'region':'RegionOne',\n        'project_name': 'admin',\n        'username': 'admin',\n        'password': 'password',\n    }\n    conn = create_connection(**auth_args)\n    list_images(conn)\n```\n\n------------------\n## 从文件中给定相关参数\n\n 新建cloud.yaml, 并加载cloud.ymal\n> ```\n> $ export OS_CLIENT_CONFIG_FILE=/yourPath/clouds.yaml\n> ```\n\n```json\ncloud.yaml\n\nclouds:\n  test_cloud:\n    region_name: RegionOne\n    auth:\n      auth_url: http://127.0.0.1:5000/v3/\n      username: admin\n      password: password\n      project_name: admin\n      domain_name: default\n```\n\n```python\nTEST_CLOUD = os.getenv('OS_TEST_CLOUD', 'test_cloud')\nclass Opts(object):\n    def __init__(self, cloud_name='test_cloud', debug=False):\n        self.cloud = cloud_name\n        self.debug = debug\n        self.identity_api_version = '3'\nopts = Opts(cloud_name=TEST_CLOUD)\nocc = os_client_config.OpenStackConfig()\ncloud = occ.get_one_cloud(opts.cloud, argparse=opts)\n\ndef list_images(conn):\n    print(\"List Images:\")\n    for image in conn.image.images():\n        print(image)\n        \n    list_images(connection.from_config(cloud_config=cloud, options=opts))\n```\n","source":"_posts/Mitaka认证的两种方式.md","raw":"---\nlayout: 获取openstack\ntitle: Mitaka认证的两种方式\ndate: 2016-04-05 04:56:12\ntags:\n - OpenStack\n---\n\n## 背景\n    随着OpenStack不断发展, 目前的MITAKA版本的keystone已经弃用了第二版本的身份认证API, 而且我在M版本下使用原来版本的keystoneclient时, 发现提示如下\n    \n>  DeprecationWarning: keystoneclient auth plugins are deprecated as of the 2.1.0 release in favor of keystoneauth1 plugins. They will be removed in future releases.\n\n    因此, 在Mitaka版本中使用keystoneclient已不可取, 而且第三版的身份认证API和第二代有比较大的不同.\n\n-------------\n## Keystone第三版身份认证相关参数\n只涉及到\n>`project_domain`: 项目域\n>`project_name`:项目(租户)\n>`user_domain_name`:用户域\n>`username`:用户名\n>`password`:密码\n>`auth_url`:认证地址, \"**http://controller:5000/v3/**\"\n> region: 区域, Regions之间完全隔离，但它们共享同一个Keystone和Dashboard服务\n> auth_plugin: 认证方式, \"**password**\"\n>其中, 高亮部分为必须参数,其余为可选参数\n\n----------------\n## 在代码中直接指定相关参数\n\n```python\ndef create_connection(project_domain_name, user_domain_name, auth_url, region, project_name, username, password):\n    prof = profile.Profile()\n    prof.set_region(profile.Profile.ALL, region)\n\n    return connection.Connection(\n        profile=prof,\n        user_agent='Autumn',\n        project_domain_name=project_domain_name,\n        user_domain_name=user_domain_name,\n        auth_url=auth_url,\n        project_name=project_name,\n        username=username,\n        password=password\n    )\n\ndef list_images(conn):\n    print(\"List Images:\")\n\n    for image in conn.image.images():\n        print(image)\n\nif __name__ == '__main__':\n\n    auth_args = {\n        'project_domain_name':'default',\n        'user_domain_name':'default',\n        'auth_url': 'http://127.0.0.1:5000/v3',\n        'region':'RegionOne',\n        'project_name': 'admin',\n        'username': 'admin',\n        'password': 'password',\n    }\n    conn = create_connection(**auth_args)\n    list_images(conn)\n```\n\n------------------\n## 从文件中给定相关参数\n\n 新建cloud.yaml, 并加载cloud.ymal\n> ```\n> $ export OS_CLIENT_CONFIG_FILE=/yourPath/clouds.yaml\n> ```\n\n```json\ncloud.yaml\n\nclouds:\n  test_cloud:\n    region_name: RegionOne\n    auth:\n      auth_url: http://127.0.0.1:5000/v3/\n      username: admin\n      password: password\n      project_name: admin\n      domain_name: default\n```\n\n```python\nTEST_CLOUD = os.getenv('OS_TEST_CLOUD', 'test_cloud')\nclass Opts(object):\n    def __init__(self, cloud_name='test_cloud', debug=False):\n        self.cloud = cloud_name\n        self.debug = debug\n        self.identity_api_version = '3'\nopts = Opts(cloud_name=TEST_CLOUD)\nocc = os_client_config.OpenStackConfig()\ncloud = occ.get_one_cloud(opts.cloud, argparse=opts)\n\ndef list_images(conn):\n    print(\"List Images:\")\n    for image in conn.image.images():\n        print(image)\n        \n    list_images(connection.from_config(cloud_config=cloud, options=opts))\n```\n","slug":"Mitaka认证的两种方式","published":1,"updated":"2017-05-15T12:00:52.737Z","comments":1,"photos":[],"link":"","_id":"cj2qy2r0g0003mqjx4axjc87a","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><pre><code>随着OpenStack不断发展, 目前的MITAKA版本的keystone已经弃用了第二版本的身份认证API, 而且我在M版本下使用原来版本的keystoneclient时, 发现提示如下\n</code></pre><blockquote>\n<p> DeprecationWarning: keystoneclient auth plugins are deprecated as of the 2.1.0 release in favor of keystoneauth1 plugins. They will be removed in future releases.</p>\n</blockquote>\n<pre><code>因此, 在Mitaka版本中使用keystoneclient已不可取, 而且第三版的身份认证API和第二代有比较大的不同.\n</code></pre><hr>\n<h2 id=\"Keystone第三版身份认证相关参数\"><a href=\"#Keystone第三版身份认证相关参数\" class=\"headerlink\" title=\"Keystone第三版身份认证相关参数\"></a>Keystone第三版身份认证相关参数</h2><p>只涉及到</p>\n<blockquote>\n<p><code>project_domain</code>: 项目域<br><code>project_name</code>:项目(租户)<br><code>user_domain_name</code>:用户域<br><code>username</code>:用户名<br><code>password</code>:密码<br><code>auth_url</code>:认证地址, “<strong><a href=\"http://controller:5000/v3/\" target=\"_blank\" rel=\"external\">http://controller:5000/v3/</a></strong>“<br>region: 区域, Regions之间完全隔离，但它们共享同一个Keystone和Dashboard服务<br>auth_plugin: 认证方式, “<strong>password</strong>“<br>其中, 高亮部分为必须参数,其余为可选参数</p>\n</blockquote>\n<hr>\n<h2 id=\"在代码中直接指定相关参数\"><a href=\"#在代码中直接指定相关参数\" class=\"headerlink\" title=\"在代码中直接指定相关参数\"></a>在代码中直接指定相关参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_connection</span><span class=\"params\">(project_domain_name, user_domain_name, auth_url, region, project_name, username, password)</span>:</span></div><div class=\"line\">    prof = profile.Profile()</div><div class=\"line\">    prof.set_region(profile.Profile.ALL, region)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> connection.Connection(</div><div class=\"line\">        profile=prof,</div><div class=\"line\">        user_agent=<span class=\"string\">'Autumn'</span>,</div><div class=\"line\">        project_domain_name=project_domain_name,</div><div class=\"line\">        user_domain_name=user_domain_name,</div><div class=\"line\">        auth_url=auth_url,</div><div class=\"line\">        project_name=project_name,</div><div class=\"line\">        username=username,</div><div class=\"line\">        password=password</div><div class=\"line\">    )</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_images</span><span class=\"params\">(conn)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"List Images:\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> conn.image.images():</div><div class=\"line\">        print(image)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\"></div><div class=\"line\">    auth_args = &#123;</div><div class=\"line\">        <span class=\"string\">'project_domain_name'</span>:<span class=\"string\">'default'</span>,</div><div class=\"line\">        <span class=\"string\">'user_domain_name'</span>:<span class=\"string\">'default'</span>,</div><div class=\"line\">        <span class=\"string\">'auth_url'</span>: <span class=\"string\">'http://127.0.0.1:5000/v3'</span>,</div><div class=\"line\">        <span class=\"string\">'region'</span>:<span class=\"string\">'RegionOne'</span>,</div><div class=\"line\">        <span class=\"string\">'project_name'</span>: <span class=\"string\">'admin'</span>,</div><div class=\"line\">        <span class=\"string\">'username'</span>: <span class=\"string\">'admin'</span>,</div><div class=\"line\">        <span class=\"string\">'password'</span>: <span class=\"string\">'password'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    conn = create_connection(**auth_args)</div><div class=\"line\">    list_images(conn)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"从文件中给定相关参数\"><a href=\"#从文件中给定相关参数\" class=\"headerlink\" title=\"从文件中给定相关参数\"></a>从文件中给定相关参数</h2><p> 新建cloud.yaml, 并加载cloud.ymal</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; $ export OS_CLIENT_CONFIG_FILE=/yourPath/clouds.yaml</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">cloud.yaml</div><div class=\"line\"></div><div class=\"line\">clouds:</div><div class=\"line\">  test_cloud:</div><div class=\"line\">    region_name: RegionOne</div><div class=\"line\">    auth:</div><div class=\"line\">      auth_url: http://127.0.0.1:5000/v3/</div><div class=\"line\">      username: admin</div><div class=\"line\">      password: password</div><div class=\"line\">      project_name: admin</div><div class=\"line\">      domain_name: default</div></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">TEST_CLOUD = os.getenv(<span class=\"string\">'OS_TEST_CLOUD'</span>, <span class=\"string\">'test_cloud'</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Opts</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, cloud_name=<span class=\"string\">'test_cloud'</span>, debug=False)</span>:</span></div><div class=\"line\">        self.cloud = cloud_name</div><div class=\"line\">        self.debug = debug</div><div class=\"line\">        self.identity_api_version = <span class=\"string\">'3'</span></div><div class=\"line\">opts = Opts(cloud_name=TEST_CLOUD)</div><div class=\"line\">occ = os_client_config.OpenStackConfig()</div><div class=\"line\">cloud = occ.get_one_cloud(opts.cloud, argparse=opts)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_images</span><span class=\"params\">(conn)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"List Images:\"</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> conn.image.images():</div><div class=\"line\">        print(image)</div><div class=\"line\">        </div><div class=\"line\">    list_images(connection.from_config(cloud_config=cloud, options=opts))</div></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><pre><code>随着OpenStack不断发展, 目前的MITAKA版本的keystone已经弃用了第二版本的身份认证API, 而且我在M版本下使用原来版本的keystoneclient时, 发现提示如下\n</code></pre><blockquote>\n<p> DeprecationWarning: keystoneclient auth plugins are deprecated as of the 2.1.0 release in favor of keystoneauth1 plugins. They will be removed in future releases.</p>\n</blockquote>\n<pre><code>因此, 在Mitaka版本中使用keystoneclient已不可取, 而且第三版的身份认证API和第二代有比较大的不同.\n</code></pre><hr>\n<h2 id=\"Keystone第三版身份认证相关参数\"><a href=\"#Keystone第三版身份认证相关参数\" class=\"headerlink\" title=\"Keystone第三版身份认证相关参数\"></a>Keystone第三版身份认证相关参数</h2><p>只涉及到</p>\n<blockquote>\n<p><code>project_domain</code>: 项目域<br><code>project_name</code>:项目(租户)<br><code>user_domain_name</code>:用户域<br><code>username</code>:用户名<br><code>password</code>:密码<br><code>auth_url</code>:认证地址, “<strong><a href=\"http://controller:5000/v3/\" target=\"_blank\" rel=\"external\">http://controller:5000/v3/</a></strong>“<br>region: 区域, Regions之间完全隔离，但它们共享同一个Keystone和Dashboard服务<br>auth_plugin: 认证方式, “<strong>password</strong>“<br>其中, 高亮部分为必须参数,其余为可选参数</p>\n</blockquote>\n<hr>\n<h2 id=\"在代码中直接指定相关参数\"><a href=\"#在代码中直接指定相关参数\" class=\"headerlink\" title=\"在代码中直接指定相关参数\"></a>在代码中直接指定相关参数</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">create_connection</span><span class=\"params\">(project_domain_name, user_domain_name, auth_url, region, project_name, username, password)</span>:</span></div><div class=\"line\">    prof = profile.Profile()</div><div class=\"line\">    prof.set_region(profile.Profile.ALL, region)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> connection.Connection(</div><div class=\"line\">        profile=prof,</div><div class=\"line\">        user_agent=<span class=\"string\">'Autumn'</span>,</div><div class=\"line\">        project_domain_name=project_domain_name,</div><div class=\"line\">        user_domain_name=user_domain_name,</div><div class=\"line\">        auth_url=auth_url,</div><div class=\"line\">        project_name=project_name,</div><div class=\"line\">        username=username,</div><div class=\"line\">        password=password</div><div class=\"line\">    )</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_images</span><span class=\"params\">(conn)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"List Images:\"</span>)</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> conn.image.images():</div><div class=\"line\">        print(image)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\"></div><div class=\"line\">    auth_args = &#123;</div><div class=\"line\">        <span class=\"string\">'project_domain_name'</span>:<span class=\"string\">'default'</span>,</div><div class=\"line\">        <span class=\"string\">'user_domain_name'</span>:<span class=\"string\">'default'</span>,</div><div class=\"line\">        <span class=\"string\">'auth_url'</span>: <span class=\"string\">'http://127.0.0.1:5000/v3'</span>,</div><div class=\"line\">        <span class=\"string\">'region'</span>:<span class=\"string\">'RegionOne'</span>,</div><div class=\"line\">        <span class=\"string\">'project_name'</span>: <span class=\"string\">'admin'</span>,</div><div class=\"line\">        <span class=\"string\">'username'</span>: <span class=\"string\">'admin'</span>,</div><div class=\"line\">        <span class=\"string\">'password'</span>: <span class=\"string\">'password'</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    conn = create_connection(**auth_args)</div><div class=\"line\">    list_images(conn)</div></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"从文件中给定相关参数\"><a href=\"#从文件中给定相关参数\" class=\"headerlink\" title=\"从文件中给定相关参数\"></a>从文件中给定相关参数</h2><p> 新建cloud.yaml, 并加载cloud.ymal</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; $ export OS_CLIENT_CONFIG_FILE=/yourPath/clouds.yaml</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">cloud.yaml</div><div class=\"line\"></div><div class=\"line\">clouds:</div><div class=\"line\">  test_cloud:</div><div class=\"line\">    region_name: RegionOne</div><div class=\"line\">    auth:</div><div class=\"line\">      auth_url: http://127.0.0.1:5000/v3/</div><div class=\"line\">      username: admin</div><div class=\"line\">      password: password</div><div class=\"line\">      project_name: admin</div><div class=\"line\">      domain_name: default</div></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">TEST_CLOUD = os.getenv(<span class=\"string\">'OS_TEST_CLOUD'</span>, <span class=\"string\">'test_cloud'</span>)</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Opts</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, cloud_name=<span class=\"string\">'test_cloud'</span>, debug=False)</span>:</span></div><div class=\"line\">        self.cloud = cloud_name</div><div class=\"line\">        self.debug = debug</div><div class=\"line\">        self.identity_api_version = <span class=\"string\">'3'</span></div><div class=\"line\">opts = Opts(cloud_name=TEST_CLOUD)</div><div class=\"line\">occ = os_client_config.OpenStackConfig()</div><div class=\"line\">cloud = occ.get_one_cloud(opts.cloud, argparse=opts)</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">list_images</span><span class=\"params\">(conn)</span>:</span></div><div class=\"line\">    print(<span class=\"string\">\"List Images:\"</span>)</div><div class=\"line\">    <span class=\"keyword\">for</span> image <span class=\"keyword\">in</span> conn.image.images():</div><div class=\"line\">        print(image)</div><div class=\"line\">        </div><div class=\"line\">    list_images(connection.from_config(cloud_config=cloud, options=opts))</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"RabbitMQ RPC中的一些细节","date":"2016-07-22T12:01:07.000Z","_content":"\n### 摘要\nRabbitMQ官网的RPC例子只是详细的说明了回调队列的使用，但对于稍微复杂的使用场景并未过多介绍，这里记录一下实际开发时的细节问题.\n\n-------\n### RPC服务端与客户端的连接问题\n如果RPC服务器与客户端运行在不同的机器上，那么应该直接采用指定具体URL的方式来连接，如下\n```python\nsparameters = pika.URLParameters(amqp)\nconn = pika.BlockingConnection(parameters)\nchannel = conn.channel()\n```\n\n\n值得注意的是URL的格式: `amqp://username:password@<ip address>:5672/<virtual host>`, 这里的`username`和`password`值的是RabbitMQ的账户与密码，`virtual host`则是虚拟主机名称，虚拟主机可以理解为namespace。而且用户的权限控制也是以虚拟主机作为粒度的。\n\n----------\n### 从回调队列看消息队列的特点\n1. 指定`exclusive=True`,则当连接断开后会RabbitMQ会自动删除这个队列\n\n2. 由于队列的`exclusive`参数为`True`,故只能在一边声明，一般我们会在客户端声明，即哪里对回调队列中的消息处理，就在哪里声明\n\n3. 由于RabbitMQ中没用超时的概念，而是通过一个`no_ack`参数来作消息确认的，默认值为`False`，即需要对消息进行确认。\n\n4. 下面通过两种场景来说明`no_ack`参数\n> 若参数值为`False`, 那么消费者如果因为某些原因宕机后，接收到了但还没还未来得及处理的消息会一直存在在队列中，并由RabbitMQ重新发送给符合转发条件的消费者，也就是消息的持久性。换句话说，消费者只有在收到消息后，并且向RabbitMQ反馈自己已经处理完消息后，RabbitMQ才会在队列中删除该消息。\\\n> 若参数值为`True`，则不需要对消息进行确认，RabbitMQ确认有消费者接收到消息后就会将消息删除。\n\n5. 队列的持久性，`no_ack`参数可以保证消息的持久性，但那时在队列持久的前提下，如果队列挂了，消息自然也就挂了，比如，RabbitMQ挂掉的时候。因此如果要保证在RabbitMQ挂掉重启后，队列中的消息不丢失，需要指定队列的`durable`参数为`True`，这就是队列的持久性\n\n-----------------\n### RPC中Exchange的使用\nRabbitMQ官网对于Exchange的使用已有很详细的教程，这里不再赘述，值得注意的是，我们去理解RabbitMQ关于RPC的模型时，抛开那些很专业性的描述不谈，其实其RPC的实现，就是双重的生产消费者，只不过有一重被约定为“Hello world”中给的模型。Client和Server之间就是生产者与消费者的关系，它们之间，你可以实现很复杂的通信模式，而Server处理完消息，返回值给Client时，就是一个\"Hello World\"的通信模式，而Client通过`correlation_id`参数来辨认回调队列中消息的归属。 \n\n考虑到高并发的效率，消息队列中的消息，不II应该是数量越多越好，也不应该是消息体越长越好，为了保证稳定性，消息应该限定在一定字节内，其余的操作可以交由数据库去处理。\n\n----------------\n### 参考：\n\n1.[pika docs][1]\n2.[RabbitMQ Tutorials][2]\n\n  [1]: https://pika.readthedocs.io/en/0.10.0/examples/using_urlparameters.html\n  [2]: http://www.rabbitmq.com/getstarted.html\n\n","source":"_posts/RPC中的具体细节.md","raw":"---\nlayout: post\ntitle: RabbitMQ RPC中的一些细节\ndate: 2016-07-22 05:01:07\ntags:\n - RPC\n---\n\n### 摘要\nRabbitMQ官网的RPC例子只是详细的说明了回调队列的使用，但对于稍微复杂的使用场景并未过多介绍，这里记录一下实际开发时的细节问题.\n\n-------\n### RPC服务端与客户端的连接问题\n如果RPC服务器与客户端运行在不同的机器上，那么应该直接采用指定具体URL的方式来连接，如下\n```python\nsparameters = pika.URLParameters(amqp)\nconn = pika.BlockingConnection(parameters)\nchannel = conn.channel()\n```\n\n\n值得注意的是URL的格式: `amqp://username:password@<ip address>:5672/<virtual host>`, 这里的`username`和`password`值的是RabbitMQ的账户与密码，`virtual host`则是虚拟主机名称，虚拟主机可以理解为namespace。而且用户的权限控制也是以虚拟主机作为粒度的。\n\n----------\n### 从回调队列看消息队列的特点\n1. 指定`exclusive=True`,则当连接断开后会RabbitMQ会自动删除这个队列\n\n2. 由于队列的`exclusive`参数为`True`,故只能在一边声明，一般我们会在客户端声明，即哪里对回调队列中的消息处理，就在哪里声明\n\n3. 由于RabbitMQ中没用超时的概念，而是通过一个`no_ack`参数来作消息确认的，默认值为`False`，即需要对消息进行确认。\n\n4. 下面通过两种场景来说明`no_ack`参数\n> 若参数值为`False`, 那么消费者如果因为某些原因宕机后，接收到了但还没还未来得及处理的消息会一直存在在队列中，并由RabbitMQ重新发送给符合转发条件的消费者，也就是消息的持久性。换句话说，消费者只有在收到消息后，并且向RabbitMQ反馈自己已经处理完消息后，RabbitMQ才会在队列中删除该消息。\\\n> 若参数值为`True`，则不需要对消息进行确认，RabbitMQ确认有消费者接收到消息后就会将消息删除。\n\n5. 队列的持久性，`no_ack`参数可以保证消息的持久性，但那时在队列持久的前提下，如果队列挂了，消息自然也就挂了，比如，RabbitMQ挂掉的时候。因此如果要保证在RabbitMQ挂掉重启后，队列中的消息不丢失，需要指定队列的`durable`参数为`True`，这就是队列的持久性\n\n-----------------\n### RPC中Exchange的使用\nRabbitMQ官网对于Exchange的使用已有很详细的教程，这里不再赘述，值得注意的是，我们去理解RabbitMQ关于RPC的模型时，抛开那些很专业性的描述不谈，其实其RPC的实现，就是双重的生产消费者，只不过有一重被约定为“Hello world”中给的模型。Client和Server之间就是生产者与消费者的关系，它们之间，你可以实现很复杂的通信模式，而Server处理完消息，返回值给Client时，就是一个\"Hello World\"的通信模式，而Client通过`correlation_id`参数来辨认回调队列中消息的归属。 \n\n考虑到高并发的效率，消息队列中的消息，不II应该是数量越多越好，也不应该是消息体越长越好，为了保证稳定性，消息应该限定在一定字节内，其余的操作可以交由数据库去处理。\n\n----------------\n### 参考：\n\n1.[pika docs][1]\n2.[RabbitMQ Tutorials][2]\n\n  [1]: https://pika.readthedocs.io/en/0.10.0/examples/using_urlparameters.html\n  [2]: http://www.rabbitmq.com/getstarted.html\n\n","slug":"RPC中的具体细节","published":1,"updated":"2017-05-15T12:12:55.906Z","comments":1,"photos":[],"link":"","_id":"cj2qy2r0k0004mqjxgiv46x62","content":"<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>RabbitMQ官网的RPC例子只是详细的说明了回调队列的使用，但对于稍微复杂的使用场景并未过多介绍，这里记录一下实际开发时的细节问题.</p>\n<hr>\n<h3 id=\"RPC服务端与客户端的连接问题\"><a href=\"#RPC服务端与客户端的连接问题\" class=\"headerlink\" title=\"RPC服务端与客户端的连接问题\"></a>RPC服务端与客户端的连接问题</h3><p>如果RPC服务器与客户端运行在不同的机器上，那么应该直接采用指定具体URL的方式来连接，如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sparameters = pika.URLParameters(amqp)</div><div class=\"line\">conn = pika.BlockingConnection(parameters)</div><div class=\"line\">channel = conn.channel()</div></pre></td></tr></table></figure></p>\n<p>值得注意的是URL的格式: <code>amqp://username:password@&lt;ip address&gt;:5672/&lt;virtual host&gt;</code>, 这里的<code>username</code>和<code>password</code>值的是RabbitMQ的账户与密码，<code>virtual host</code>则是虚拟主机名称，虚拟主机可以理解为namespace。而且用户的权限控制也是以虚拟主机作为粒度的。</p>\n<hr>\n<h3 id=\"从回调队列看消息队列的特点\"><a href=\"#从回调队列看消息队列的特点\" class=\"headerlink\" title=\"从回调队列看消息队列的特点\"></a>从回调队列看消息队列的特点</h3><ol>\n<li><p>指定<code>exclusive=True</code>,则当连接断开后会RabbitMQ会自动删除这个队列</p>\n</li>\n<li><p>由于队列的<code>exclusive</code>参数为<code>True</code>,故只能在一边声明，一般我们会在客户端声明，即哪里对回调队列中的消息处理，就在哪里声明</p>\n</li>\n<li><p>由于RabbitMQ中没用超时的概念，而是通过一个<code>no_ack</code>参数来作消息确认的，默认值为<code>False</code>，即需要对消息进行确认。</p>\n</li>\n<li><p>下面通过两种场景来说明<code>no_ack</code>参数</p>\n<blockquote>\n<p>若参数值为<code>False</code>, 那么消费者如果因为某些原因宕机后，接收到了但还没还未来得及处理的消息会一直存在在队列中，并由RabbitMQ重新发送给符合转发条件的消费者，也就是消息的持久性。换句话说，消费者只有在收到消息后，并且向RabbitMQ反馈自己已经处理完消息后，RabbitMQ才会在队列中删除该消息。\\<br>若参数值为<code>True</code>，则不需要对消息进行确认，RabbitMQ确认有消费者接收到消息后就会将消息删除。</p>\n</blockquote>\n</li>\n<li><p>队列的持久性，<code>no_ack</code>参数可以保证消息的持久性，但那时在队列持久的前提下，如果队列挂了，消息自然也就挂了，比如，RabbitMQ挂掉的时候。因此如果要保证在RabbitMQ挂掉重启后，队列中的消息不丢失，需要指定队列的<code>durable</code>参数为<code>True</code>，这就是队列的持久性</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"RPC中Exchange的使用\"><a href=\"#RPC中Exchange的使用\" class=\"headerlink\" title=\"RPC中Exchange的使用\"></a>RPC中Exchange的使用</h3><p>RabbitMQ官网对于Exchange的使用已有很详细的教程，这里不再赘述，值得注意的是，我们去理解RabbitMQ关于RPC的模型时，抛开那些很专业性的描述不谈，其实其RPC的实现，就是双重的生产消费者，只不过有一重被约定为“Hello world”中给的模型。Client和Server之间就是生产者与消费者的关系，它们之间，你可以实现很复杂的通信模式，而Server处理完消息，返回值给Client时，就是一个”Hello World”的通信模式，而Client通过<code>correlation_id</code>参数来辨认回调队列中消息的归属。 </p>\n<p>考虑到高并发的效率，消息队列中的消息，不II应该是数量越多越好，也不应该是消息体越长越好，为了保证稳定性，消息应该限定在一定字节内，其余的操作可以交由数据库去处理。</p>\n<hr>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>1.<a href=\"https://pika.readthedocs.io/en/0.10.0/examples/using_urlparameters.html\" target=\"_blank\" rel=\"external\">pika docs</a><br>2.<a href=\"http://www.rabbitmq.com/getstarted.html\" target=\"_blank\" rel=\"external\">RabbitMQ Tutorials</a></p>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>RabbitMQ官网的RPC例子只是详细的说明了回调队列的使用，但对于稍微复杂的使用场景并未过多介绍，这里记录一下实际开发时的细节问题.</p>\n<hr>\n<h3 id=\"RPC服务端与客户端的连接问题\"><a href=\"#RPC服务端与客户端的连接问题\" class=\"headerlink\" title=\"RPC服务端与客户端的连接问题\"></a>RPC服务端与客户端的连接问题</h3><p>如果RPC服务器与客户端运行在不同的机器上，那么应该直接采用指定具体URL的方式来连接，如下<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sparameters = pika.URLParameters(amqp)</div><div class=\"line\">conn = pika.BlockingConnection(parameters)</div><div class=\"line\">channel = conn.channel()</div></pre></td></tr></table></figure></p>\n<p>值得注意的是URL的格式: <code>amqp://username:password@&lt;ip address&gt;:5672/&lt;virtual host&gt;</code>, 这里的<code>username</code>和<code>password</code>值的是RabbitMQ的账户与密码，<code>virtual host</code>则是虚拟主机名称，虚拟主机可以理解为namespace。而且用户的权限控制也是以虚拟主机作为粒度的。</p>\n<hr>\n<h3 id=\"从回调队列看消息队列的特点\"><a href=\"#从回调队列看消息队列的特点\" class=\"headerlink\" title=\"从回调队列看消息队列的特点\"></a>从回调队列看消息队列的特点</h3><ol>\n<li><p>指定<code>exclusive=True</code>,则当连接断开后会RabbitMQ会自动删除这个队列</p>\n</li>\n<li><p>由于队列的<code>exclusive</code>参数为<code>True</code>,故只能在一边声明，一般我们会在客户端声明，即哪里对回调队列中的消息处理，就在哪里声明</p>\n</li>\n<li><p>由于RabbitMQ中没用超时的概念，而是通过一个<code>no_ack</code>参数来作消息确认的，默认值为<code>False</code>，即需要对消息进行确认。</p>\n</li>\n<li><p>下面通过两种场景来说明<code>no_ack</code>参数</p>\n<blockquote>\n<p>若参数值为<code>False</code>, 那么消费者如果因为某些原因宕机后，接收到了但还没还未来得及处理的消息会一直存在在队列中，并由RabbitMQ重新发送给符合转发条件的消费者，也就是消息的持久性。换句话说，消费者只有在收到消息后，并且向RabbitMQ反馈自己已经处理完消息后，RabbitMQ才会在队列中删除该消息。\\<br>若参数值为<code>True</code>，则不需要对消息进行确认，RabbitMQ确认有消费者接收到消息后就会将消息删除。</p>\n</blockquote>\n</li>\n<li><p>队列的持久性，<code>no_ack</code>参数可以保证消息的持久性，但那时在队列持久的前提下，如果队列挂了，消息自然也就挂了，比如，RabbitMQ挂掉的时候。因此如果要保证在RabbitMQ挂掉重启后，队列中的消息不丢失，需要指定队列的<code>durable</code>参数为<code>True</code>，这就是队列的持久性</p>\n</li>\n</ol>\n<hr>\n<h3 id=\"RPC中Exchange的使用\"><a href=\"#RPC中Exchange的使用\" class=\"headerlink\" title=\"RPC中Exchange的使用\"></a>RPC中Exchange的使用</h3><p>RabbitMQ官网对于Exchange的使用已有很详细的教程，这里不再赘述，值得注意的是，我们去理解RabbitMQ关于RPC的模型时，抛开那些很专业性的描述不谈，其实其RPC的实现，就是双重的生产消费者，只不过有一重被约定为“Hello world”中给的模型。Client和Server之间就是生产者与消费者的关系，它们之间，你可以实现很复杂的通信模式，而Server处理完消息，返回值给Client时，就是一个”Hello World”的通信模式，而Client通过<code>correlation_id</code>参数来辨认回调队列中消息的归属。 </p>\n<p>考虑到高并发的效率，消息队列中的消息，不II应该是数量越多越好，也不应该是消息体越长越好，为了保证稳定性，消息应该限定在一定字节内，其余的操作可以交由数据库去处理。</p>\n<hr>\n<h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><p>1.<a href=\"https://pika.readthedocs.io/en/0.10.0/examples/using_urlparameters.html\" target=\"_blank\" rel=\"external\">pika docs</a><br>2.<a href=\"http://www.rabbitmq.com/getstarted.html\" target=\"_blank\" rel=\"external\">RabbitMQ Tutorials</a></p>\n"},{"title":"RabbitMQ的RPC实现","date":"2016-05-01T11:50:51.000Z","_content":"## 基本概念\n### Callback queue 回调队列\n一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址`reply_to`。\n\n### Correlation id 关联标识\n一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有`correlation_id`属性，这样客户端在回调队列中根据`correlation_id`字段的值就可以分辨此响应属于哪个请求。\n\n------------------------\n## 工作流程\n### RPC\n> `客户端初始化`：启动后，创建一个独有的回调队列\n> \n> `客户端发送请求`：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到`RPC请求队列`时，客户端至少发送带有`reply_to`以及`correlation_id`两个属性的信息\n> \n> `服务器端工作流`： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从`RPC请求队列`中取出请求，然后处理后，将响应发送到`reply_to`指定的回调队列中\n> \n> `客户端接受处理结果`： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中`correlation_id`字段的值，将其返回给对应的应用\n\n### 服务器端\n```python\n#!/usr/bin/env python\nimport pika\n\n# 建立连接，服务器地址为localhost，可指定ip地址\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host='localhost'))\n\n# 建立会话\nchannel = connection.channel()\n\n# 声明RPC请求队列\nchannel.queue_declare(queue='rpc_queue')\n\n# 数据处理方法\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n# 对RPC请求队列中的请求进行处理\ndef on_request(ch, method, props, body):\n    n = int(body)\n\n    print(\" [.] fib(%s)\" % n)\n    \n    # 调用数据处理方法\n    response = fib(n)\n\n\t# 将处理结果(响应)发送到回调队列\n    ch.basic_publish(exchange='',\n                     routing_key=props.reply_to,\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=str(response))\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\n# 负载均衡，同一时刻发送给该服务器的请求不超过一个\nchannel.basic_qos(prefetch_count=1)\n\n='''''''''''''''''''''''''''=p-;//==\n]]hhnhgb[[# 服务器订阅RPC请求队列，当队列中有请求时，将调用`on_request`方法处理请求\nchannel.basic_consume(on_request, queue='rpc_queue')\n\nprint(\" [x] Awaiting RPC requests\")\nchannel.start_consuming()\n```\n\n\n### 客户端\n```python\n#!/usr/bin/env python\nimport pika\nimport uuid\n\nclass FibonacciRpcClient(object):\n    def __init__(self):\n \t\t”“”\n        客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应\n        \n        “”“\n        \n        # 建立连接，指定服务器的ip地址\n        self.connection = pika.BlockingConnection(pika.ConnectionParameters(\n                host='localhost'))\n                \n\t\t# 建立一个会话，每个channel代表一个会话任务\n        self.channel = self.connection.channel()\n\t\t\n        # 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次\n        result = self.channel.queue_declare(exclusive=True)\n        # 将次队列指定为当前客户端的回调队列\n        self.callback_queue = result.method.queue\n\t\t\n        # 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理; \n        self.channel.basic_consume(self.on_response, no_ack=True,\n                                   queue=self.callback_queue)\n\n\n\t# 对回调队列中的响应进行处理的函数\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body\n\n\n\t# 发出RPC请求\n    def call(self, n):\n    \n    \t# 初始化 response\n        self.response = None\n        \n        #生成correlation_id \n        self.corr_id = str(uuid.uuid4())\n        \n        # 发送RPC请求内容到RPC请求队列`rpc_queue`，同时发送的还有`reply_to`和`correlation_id`\n        self.channel.basic_publish(exchange='',\n                                   routing_key='rpc_queue',\n                                   properties=pika.BasicProperties(\n                                         reply_to = self.callback_queue,\n                                         correlation_id = self.corr_id,\n                                         ),\n                                   body=str(n))\n                                   \n        \n        while self.response is None:\n            self.connection.process_data_events()\n        return int(self.response)\n\n# 建立客户端\nfibonacci_rpc = FibonacciRpcClient()\n\n# 发送RPC请求\nprint(\" [x] Requesting fib(30)\")\nresponse = fibonacci_rpc.call(30)\nprint(\" [.] Got %r\" % response)\n```\n","source":"_posts/RabbitMQ的RPC实现.md","raw":"---\ntitle: RabbitMQ的RPC实现\ndate: 2016-04-31 04:50:51\ntags:\n - RabbitMQ\n---\n## 基本概念\n### Callback queue 回调队列\n一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址`reply_to`。\n\n### Correlation id 关联标识\n一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有`correlation_id`属性，这样客户端在回调队列中根据`correlation_id`字段的值就可以分辨此响应属于哪个请求。\n\n------------------------\n## 工作流程\n### RPC\n> `客户端初始化`：启动后，创建一个独有的回调队列\n> \n> `客户端发送请求`：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到`RPC请求队列`时，客户端至少发送带有`reply_to`以及`correlation_id`两个属性的信息\n> \n> `服务器端工作流`： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从`RPC请求队列`中取出请求，然后处理后，将响应发送到`reply_to`指定的回调队列中\n> \n> `客户端接受处理结果`： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中`correlation_id`字段的值，将其返回给对应的应用\n\n### 服务器端\n```python\n#!/usr/bin/env python\nimport pika\n\n# 建立连接，服务器地址为localhost，可指定ip地址\nconnection = pika.BlockingConnection(pika.ConnectionParameters(\n        host='localhost'))\n\n# 建立会话\nchannel = connection.channel()\n\n# 声明RPC请求队列\nchannel.queue_declare(queue='rpc_queue')\n\n# 数据处理方法\ndef fib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\n\n# 对RPC请求队列中的请求进行处理\ndef on_request(ch, method, props, body):\n    n = int(body)\n\n    print(\" [.] fib(%s)\" % n)\n    \n    # 调用数据处理方法\n    response = fib(n)\n\n\t# 将处理结果(响应)发送到回调队列\n    ch.basic_publish(exchange='',\n                     routing_key=props.reply_to,\n                     properties=pika.BasicProperties(correlation_id = \\\n                                                         props.correlation_id),\n                     body=str(response))\n    ch.basic_ack(delivery_tag = method.delivery_tag)\n\n# 负载均衡，同一时刻发送给该服务器的请求不超过一个\nchannel.basic_qos(prefetch_count=1)\n\n='''''''''''''''''''''''''''=p-;//==\n]]hhnhgb[[# 服务器订阅RPC请求队列，当队列中有请求时，将调用`on_request`方法处理请求\nchannel.basic_consume(on_request, queue='rpc_queue')\n\nprint(\" [x] Awaiting RPC requests\")\nchannel.start_consuming()\n```\n\n\n### 客户端\n```python\n#!/usr/bin/env python\nimport pika\nimport uuid\n\nclass FibonacciRpcClient(object):\n    def __init__(self):\n \t\t”“”\n        客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应\n        \n        “”“\n        \n        # 建立连接，指定服务器的ip地址\n        self.connection = pika.BlockingConnection(pika.ConnectionParameters(\n                host='localhost'))\n                \n\t\t# 建立一个会话，每个channel代表一个会话任务\n        self.channel = self.connection.channel()\n\t\t\n        # 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次\n        result = self.channel.queue_declare(exclusive=True)\n        # 将次队列指定为当前客户端的回调队列\n        self.callback_queue = result.method.queue\n\t\t\n        # 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理; \n        self.channel.basic_consume(self.on_response, no_ack=True,\n                                   queue=self.callback_queue)\n\n\n\t# 对回调队列中的响应进行处理的函数\n    def on_response(self, ch, method, props, body):\n        if self.corr_id == props.correlation_id:\n            self.response = body\n\n\n\t# 发出RPC请求\n    def call(self, n):\n    \n    \t# 初始化 response\n        self.response = None\n        \n        #生成correlation_id \n        self.corr_id = str(uuid.uuid4())\n        \n        # 发送RPC请求内容到RPC请求队列`rpc_queue`，同时发送的还有`reply_to`和`correlation_id`\n        self.channel.basic_publish(exchange='',\n                                   routing_key='rpc_queue',\n                                   properties=pika.BasicProperties(\n                                         reply_to = self.callback_queue,\n                                         correlation_id = self.corr_id,\n                                         ),\n                                   body=str(n))\n                                   \n        \n        while self.response is None:\n            self.connection.process_data_events()\n        return int(self.response)\n\n# 建立客户端\nfibonacci_rpc = FibonacciRpcClient()\n\n# 发送RPC请求\nprint(\" [x] Requesting fib(30)\")\nresponse = fibonacci_rpc.call(30)\nprint(\" [.] Got %r\" % response)\n```\n","slug":"RabbitMQ的RPC实现","published":1,"updated":"2017-05-15T11:55:53.900Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r0m0005mqjx7hspjri1","content":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Callback-queue-回调队列\"><a href=\"#Callback-queue-回调队列\" class=\"headerlink\" title=\"Callback queue 回调队列\"></a>Callback queue 回调队列</h3><p>一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址<code>reply_to</code>。</p>\n<h3 id=\"Correlation-id-关联标识\"><a href=\"#Correlation-id-关联标识\" class=\"headerlink\" title=\"Correlation id 关联标识\"></a>Correlation id 关联标识</h3><p>一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有<code>correlation_id</code>属性，这样客户端在回调队列中根据<code>correlation_id</code>字段的值就可以分辨此响应属于哪个请求。</p>\n<hr>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><blockquote>\n<p><code>客户端初始化</code>：启动后，创建一个独有的回调队列</p>\n<p><code>客户端发送请求</code>：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到<code>RPC请求队列</code>时，客户端至少发送带有<code>reply_to</code>以及<code>correlation_id</code>两个属性的信息</p>\n<p><code>服务器端工作流</code>： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从<code>RPC请求队列</code>中取出请求，然后处理后，将响应发送到<code>reply_to</code>指定的回调队列中</p>\n<p><code>客户端接受处理结果</code>： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中<code>correlation_id</code>字段的值，将其返回给对应的应用</p>\n</blockquote>\n<h3 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立连接，服务器地址为localhost，可指定ip地址</span></div><div class=\"line\">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class=\"line\">        host=<span class=\"string\">'localhost'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立会话</span></div><div class=\"line\">channel = connection.channel()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 声明RPC请求队列</span></div><div class=\"line\">channel.queue_declare(queue=<span class=\"string\">'rpc_queue'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 数据处理方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>) + fib(n<span class=\"number\">-2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 对RPC请求队列中的请求进行处理</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">on_request</span><span class=\"params\">(ch, method, props, body)</span>:</span></div><div class=\"line\">    n = int(body)</div><div class=\"line\"></div><div class=\"line\">    print(<span class=\"string\">\" [.] fib(%s)\"</span> % n)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\"># 调用数据处理方法</span></div><div class=\"line\">    response = fib(n)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 将处理结果(响应)发送到回调队列</span></div><div class=\"line\">    ch.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                     routing_key=props.reply_to,</div><div class=\"line\">                     properties=pika.BasicProperties(correlation_id = \\</div><div class=\"line\">                                                         props.correlation_id),</div><div class=\"line\">                     body=str(response))</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 负载均衡，同一时刻发送给该服务器的请求不超过一个</span></div><div class=\"line\">channel.basic_qos(prefetch_count=<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">=<span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">'''=p-;//==</span></div><div class=\"line\">]]hhnhgb[[# 服务器订阅RPC请求队列，当队列中有请求时，将调用`on_request`方法处理请求</div><div class=\"line\">channel.basic_consume(on_request, queue='rpc_queue')</div><div class=\"line\"></div><div class=\"line\">print(\" [x] Awaiting RPC requests\")</div><div class=\"line\">channel.start_consuming()</div></pre></td></tr></table></figure>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> uuid</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FibonacciRpcClient</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"> \t\t”“”</div><div class=\"line\">        客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应</div><div class=\"line\">        </div><div class=\"line\">        “”“</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\"># 建立连接，指定服务器的ip地址</span></div><div class=\"line\">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class=\"line\">                host=<span class=\"string\">'localhost'</span>))</div><div class=\"line\">                </div><div class=\"line\">\t\t<span class=\"comment\"># 建立一个会话，每个channel代表一个会话任务</span></div><div class=\"line\">        self.channel = self.connection.channel()</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\"># 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次</span></div><div class=\"line\">        result = self.channel.queue_declare(exclusive=<span class=\"keyword\">True</span>)</div><div class=\"line\">        <span class=\"comment\"># 将次队列指定为当前客户端的回调队列</span></div><div class=\"line\">        self.callback_queue = result.method.queue</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\"># 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理; </span></div><div class=\"line\">        self.channel.basic_consume(self.on_response, no_ack=<span class=\"keyword\">True</span>,</div><div class=\"line\">                                   queue=self.callback_queue)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 对回调队列中的响应进行处理的函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">on_response</span><span class=\"params\">(self, ch, method, props, body)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.corr_id == props.correlation_id:</div><div class=\"line\">            self.response = body</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 发出RPC请求</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">    </div><div class=\"line\">    \t<span class=\"comment\"># 初始化 response</span></div><div class=\"line\">        self.response = <span class=\"keyword\">None</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">#生成correlation_id </span></div><div class=\"line\">        self.corr_id = str(uuid.uuid4())</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\"># 发送RPC请求内容到RPC请求队列`rpc_queue`，同时发送的还有`reply_to`和`correlation_id`</span></div><div class=\"line\">        self.channel.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                                   routing_key=<span class=\"string\">'rpc_queue'</span>,</div><div class=\"line\">                                   properties=pika.BasicProperties(</div><div class=\"line\">                                         reply_to = self.callback_queue,</div><div class=\"line\">                                         correlation_id = self.corr_id,</div><div class=\"line\">                                         ),</div><div class=\"line\">                                   body=str(n))</div><div class=\"line\">                                   </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">while</span> self.response <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            self.connection.process_data_events()</div><div class=\"line\">        <span class=\"keyword\">return</span> int(self.response)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立客户端</span></div><div class=\"line\">fibonacci_rpc = FibonacciRpcClient()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 发送RPC请求</span></div><div class=\"line\">print(<span class=\"string\">\" [x] Requesting fib(30)\"</span>)</div><div class=\"line\">response = fibonacci_rpc.call(<span class=\"number\">30</span>)</div><div class=\"line\">print(<span class=\"string\">\" [.] Got %r\"</span> % response)</div></pre></td></tr></table></figure>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h3 id=\"Callback-queue-回调队列\"><a href=\"#Callback-queue-回调队列\" class=\"headerlink\" title=\"Callback queue 回调队列\"></a>Callback queue 回调队列</h3><p>一个客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址<code>reply_to</code>。</p>\n<h3 id=\"Correlation-id-关联标识\"><a href=\"#Correlation-id-关联标识\" class=\"headerlink\" title=\"Correlation id 关联标识\"></a>Correlation id 关联标识</h3><p>一个客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有<code>correlation_id</code>属性，这样客户端在回调队列中根据<code>correlation_id</code>字段的值就可以分辨此响应属于哪个请求。</p>\n<hr>\n<h2 id=\"工作流程\"><a href=\"#工作流程\" class=\"headerlink\" title=\"工作流程\"></a>工作流程</h2><h3 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h3><blockquote>\n<p><code>客户端初始化</code>：启动后，创建一个独有的回调队列</p>\n<p><code>客户端发送请求</code>：某个应用将请求信息交给客户端，然后客户端发送RPC请求，在发送RPC请求到<code>RPC请求队列</code>时，客户端至少发送带有<code>reply_to</code>以及<code>correlation_id</code>两个属性的信息</p>\n<p><code>服务器端工作流</code>： 等待接受客户端发来RPC请求，当请求出现的时候，服务器从<code>RPC请求队列</code>中取出请求，然后处理后，将响应发送到<code>reply_to</code>指定的回调队列中</p>\n<p><code>客户端接受处理结果</code>： 客户端等待回调队列中出现响应，当响应出现时，它会根据响应中<code>correlation_id</code>字段的值，将其返回给对应的应用</p>\n</blockquote>\n<h3 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立连接，服务器地址为localhost，可指定ip地址</span></div><div class=\"line\">connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class=\"line\">        host=<span class=\"string\">'localhost'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立会话</span></div><div class=\"line\">channel = connection.channel()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 声明RPC请求队列</span></div><div class=\"line\">channel.queue_declare(queue=<span class=\"string\">'rpc_queue'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 数据处理方法</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fib</span><span class=\"params\">(n)</span>:</span></div><div class=\"line\">    <span class=\"keyword\">if</span> n == <span class=\"number\">0</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></div><div class=\"line\">    <span class=\"keyword\">elif</span> n == <span class=\"number\">1</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></div><div class=\"line\">    <span class=\"keyword\">else</span>:</div><div class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>) + fib(n<span class=\"number\">-2</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 对RPC请求队列中的请求进行处理</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">on_request</span><span class=\"params\">(ch, method, props, body)</span>:</span></div><div class=\"line\">    n = int(body)</div><div class=\"line\"></div><div class=\"line\">    print(<span class=\"string\">\" [.] fib(%s)\"</span> % n)</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"comment\"># 调用数据处理方法</span></div><div class=\"line\">    response = fib(n)</div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 将处理结果(响应)发送到回调队列</span></div><div class=\"line\">    ch.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                     routing_key=props.reply_to,</div><div class=\"line\">                     properties=pika.BasicProperties(correlation_id = \\</div><div class=\"line\">                                                         props.correlation_id),</div><div class=\"line\">                     body=str(response))</div><div class=\"line\">    ch.basic_ack(delivery_tag = method.delivery_tag)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 负载均衡，同一时刻发送给该服务器的请求不超过一个</span></div><div class=\"line\">channel.basic_qos(prefetch_count=<span class=\"number\">1</span>)</div><div class=\"line\"></div><div class=\"line\">=<span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">''''''</span><span class=\"string\">'''=p-;//==</span></div><div class=\"line\">]]hhnhgb[[# 服务器订阅RPC请求队列，当队列中有请求时，将调用`on_request`方法处理请求</div><div class=\"line\">channel.basic_consume(on_request, queue='rpc_queue')</div><div class=\"line\"></div><div class=\"line\">print(\" [x] Awaiting RPC requests\")</div><div class=\"line\">channel.start_consuming()</div></pre></td></tr></table></figure>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></div><div class=\"line\"><span class=\"keyword\">import</span> pika</div><div class=\"line\"><span class=\"keyword\">import</span> uuid</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FibonacciRpcClient</span><span class=\"params\">(object)</span>:</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></div><div class=\"line\"> \t\t”“”</div><div class=\"line\">        客户端启动时，创建回调队列，会开启会话用于发送RPC请求以及接受响应</div><div class=\"line\">        </div><div class=\"line\">        “”“</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\"># 建立连接，指定服务器的ip地址</span></div><div class=\"line\">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(</div><div class=\"line\">                host=<span class=\"string\">'localhost'</span>))</div><div class=\"line\">                </div><div class=\"line\">\t\t<span class=\"comment\"># 建立一个会话，每个channel代表一个会话任务</span></div><div class=\"line\">        self.channel = self.connection.channel()</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\"># 声明回调队列，再次声明的原因是，服务器和客户端可能先后开启，该声明是幂等的，多次声明，但只生效一次</span></div><div class=\"line\">        result = self.channel.queue_declare(exclusive=<span class=\"keyword\">True</span>)</div><div class=\"line\">        <span class=\"comment\"># 将次队列指定为当前客户端的回调队列</span></div><div class=\"line\">        self.callback_queue = result.method.queue</div><div class=\"line\">\t\t</div><div class=\"line\">        <span class=\"comment\"># 客户端订阅回调队列，当回调队列中有响应时，调用`on_response`方法对响应进行处理; </span></div><div class=\"line\">        self.channel.basic_consume(self.on_response, no_ack=<span class=\"keyword\">True</span>,</div><div class=\"line\">                                   queue=self.callback_queue)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 对回调队列中的响应进行处理的函数</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">on_response</span><span class=\"params\">(self, ch, method, props, body)</span>:</span></div><div class=\"line\">        <span class=\"keyword\">if</span> self.corr_id == props.correlation_id:</div><div class=\"line\">            self.response = body</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">\t<span class=\"comment\"># 发出RPC请求</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">call</span><span class=\"params\">(self, n)</span>:</span></div><div class=\"line\">    </div><div class=\"line\">    \t<span class=\"comment\"># 初始化 response</span></div><div class=\"line\">        self.response = <span class=\"keyword\">None</span></div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\">#生成correlation_id </span></div><div class=\"line\">        self.corr_id = str(uuid.uuid4())</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"comment\"># 发送RPC请求内容到RPC请求队列`rpc_queue`，同时发送的还有`reply_to`和`correlation_id`</span></div><div class=\"line\">        self.channel.basic_publish(exchange=<span class=\"string\">''</span>,</div><div class=\"line\">                                   routing_key=<span class=\"string\">'rpc_queue'</span>,</div><div class=\"line\">                                   properties=pika.BasicProperties(</div><div class=\"line\">                                         reply_to = self.callback_queue,</div><div class=\"line\">                                         correlation_id = self.corr_id,</div><div class=\"line\">                                         ),</div><div class=\"line\">                                   body=str(n))</div><div class=\"line\">                                   </div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">while</span> self.response <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</div><div class=\"line\">            self.connection.process_data_events()</div><div class=\"line\">        <span class=\"keyword\">return</span> int(self.response)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 建立客户端</span></div><div class=\"line\">fibonacci_rpc = FibonacciRpcClient()</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\"># 发送RPC请求</span></div><div class=\"line\">print(<span class=\"string\">\" [x] Requesting fib(30)\"</span>)</div><div class=\"line\">response = fibonacci_rpc.call(<span class=\"number\">30</span>)</div><div class=\"line\">print(<span class=\"string\">\" [.] Got %r\"</span> % response)</div></pre></td></tr></table></figure>\n"},{"layout":"post","title":"OpenStack Ubuntu镜像制作","date":"2016-12-03T13:10:54.000Z","_content":"\n>##### **制作之前**\n>\n* 在主机创建一个**kvm**虚拟机**VM**(本文使用Ubuntu 12.04LTS)，使用**默认**的分区方式\n* 你可以**在VM中配置好你想要的环境**\n* 本文中将使用VM的磁盘文件**VM.img**制作一个在**OpenStack**(测试环境为kilo)中可用的镜像\n\n##### 1.在虚拟机中的配置\n*  安装cloud-init，openssh软件包\n>  $ sudo apt-get install cloud-init openssh-server\n* 配置元数据源\n> $ sudo dpkg-reconfigure cloud-init\n\n  > 选中**EC2**数据源，保存退出\n\n* 修改**cloud-init**使用的账户名为admin\n> $ sudo vi **/etc/cloud/cloud.cfg**\n\n  >修改user的参数为admin，如下\n>     user:admin\n\n* 关闭虚拟机\n> $ sudo shutdown -h now\n\n##### 2.在主机上的操作\n* 清除VM镜像中的MAC地址相关的信息\n>  $ sudo virt-sysprep -d **VM**\n\n* 删除主机中的**VM**虚拟机定义\n> $ sudo virsh undefine **VM**\n\n* 上传镜像至**Glance**服务\n> $ glance image-create --name \"**VM-templet**\" --file  **VM.img** --disk-format **qcow2** --container-format bare --visibility public --progress\n\n##### Done!\n","source":"_posts/Ubuntu镜像制作.md","raw":"---\nlayout: post\ntitle: OpenStack Ubuntu镜像制作\ndate: 2016-12-3 05:10:54\ntags:\n - OpenStack\n---\n\n>##### **制作之前**\n>\n* 在主机创建一个**kvm**虚拟机**VM**(本文使用Ubuntu 12.04LTS)，使用**默认**的分区方式\n* 你可以**在VM中配置好你想要的环境**\n* 本文中将使用VM的磁盘文件**VM.img**制作一个在**OpenStack**(测试环境为kilo)中可用的镜像\n\n##### 1.在虚拟机中的配置\n*  安装cloud-init，openssh软件包\n>  $ sudo apt-get install cloud-init openssh-server\n* 配置元数据源\n> $ sudo dpkg-reconfigure cloud-init\n\n  > 选中**EC2**数据源，保存退出\n\n* 修改**cloud-init**使用的账户名为admin\n> $ sudo vi **/etc/cloud/cloud.cfg**\n\n  >修改user的参数为admin，如下\n>     user:admin\n\n* 关闭虚拟机\n> $ sudo shutdown -h now\n\n##### 2.在主机上的操作\n* 清除VM镜像中的MAC地址相关的信息\n>  $ sudo virt-sysprep -d **VM**\n\n* 删除主机中的**VM**虚拟机定义\n> $ sudo virsh undefine **VM**\n\n* 上传镜像至**Glance**服务\n> $ glance image-create --name \"**VM-templet**\" --file  **VM.img** --disk-format **qcow2** --container-format bare --visibility public --progress\n\n##### Done!\n","slug":"Ubuntu镜像制作","published":1,"updated":"2017-05-15T12:17:13.079Z","comments":1,"photos":[],"link":"","_id":"cj2qy2r0p0008mqjxo2icr4re","content":"<blockquote>\n<h5 id=\"制作之前\"><a href=\"#制作之前\" class=\"headerlink\" title=\"制作之前\"></a><strong>制作之前</strong></h5><ul>\n<li>在主机创建一个<strong>kvm</strong>虚拟机<strong>VM</strong>(本文使用Ubuntu 12.04LTS)，使用<strong>默认</strong>的分区方式</li>\n<li>你可以<strong>在VM中配置好你想要的环境</strong></li>\n<li>本文中将使用VM的磁盘文件<strong>VM.img</strong>制作一个在<strong>OpenStack</strong>(测试环境为kilo)中可用的镜像</li>\n</ul>\n</blockquote>\n<h5 id=\"1-在虚拟机中的配置\"><a href=\"#1-在虚拟机中的配置\" class=\"headerlink\" title=\"1.在虚拟机中的配置\"></a>1.在虚拟机中的配置</h5><ul>\n<li>安装cloud-init，openssh软件包<blockquote>\n<p> $ sudo apt-get install cloud-init openssh-server</p>\n</blockquote>\n</li>\n<li><p>配置元数据源</p>\n<blockquote>\n<p>$ sudo dpkg-reconfigure cloud-init</p>\n<p>选中<strong>EC2</strong>数据源，保存退出</p>\n</blockquote>\n</li>\n<li><p>修改<strong>cloud-init</strong>使用的账户名为admin</p>\n<blockquote>\n<p>$ sudo vi <strong>/etc/cloud/cloud.cfg</strong></p>\n<p>修改user的参数为admin，如下</p>\n<pre><code>user:admin\n</code></pre></blockquote>\n</li>\n<li><p>关闭虚拟机</p>\n<blockquote>\n<p>$ sudo shutdown -h now</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"2-在主机上的操作\"><a href=\"#2-在主机上的操作\" class=\"headerlink\" title=\"2.在主机上的操作\"></a>2.在主机上的操作</h5><ul>\n<li><p>清除VM镜像中的MAC地址相关的信息</p>\n<blockquote>\n<p> $ sudo virt-sysprep -d <strong>VM</strong></p>\n</blockquote>\n</li>\n<li><p>删除主机中的<strong>VM</strong>虚拟机定义</p>\n<blockquote>\n<p>$ sudo virsh undefine <strong>VM</strong></p>\n</blockquote>\n</li>\n<li><p>上传镜像至<strong>Glance</strong>服务</p>\n<blockquote>\n<p>$ glance image-create –name “<strong>VM-templet</strong>“ –file  <strong>VM.img</strong> –disk-format <strong>qcow2</strong> –container-format bare –visibility public –progress</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done!\"></a>Done!</h5>","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<blockquote>\n<h5 id=\"制作之前\"><a href=\"#制作之前\" class=\"headerlink\" title=\"制作之前\"></a><strong>制作之前</strong></h5><ul>\n<li>在主机创建一个<strong>kvm</strong>虚拟机<strong>VM</strong>(本文使用Ubuntu 12.04LTS)，使用<strong>默认</strong>的分区方式</li>\n<li>你可以<strong>在VM中配置好你想要的环境</strong></li>\n<li>本文中将使用VM的磁盘文件<strong>VM.img</strong>制作一个在<strong>OpenStack</strong>(测试环境为kilo)中可用的镜像</li>\n</ul>\n</blockquote>\n<h5 id=\"1-在虚拟机中的配置\"><a href=\"#1-在虚拟机中的配置\" class=\"headerlink\" title=\"1.在虚拟机中的配置\"></a>1.在虚拟机中的配置</h5><ul>\n<li>安装cloud-init，openssh软件包<blockquote>\n<p> $ sudo apt-get install cloud-init openssh-server</p>\n</blockquote>\n</li>\n<li><p>配置元数据源</p>\n<blockquote>\n<p>$ sudo dpkg-reconfigure cloud-init</p>\n<p>选中<strong>EC2</strong>数据源，保存退出</p>\n</blockquote>\n</li>\n<li><p>修改<strong>cloud-init</strong>使用的账户名为admin</p>\n<blockquote>\n<p>$ sudo vi <strong>/etc/cloud/cloud.cfg</strong></p>\n<p>修改user的参数为admin，如下</p>\n<pre><code>user:admin\n</code></pre></blockquote>\n</li>\n<li><p>关闭虚拟机</p>\n<blockquote>\n<p>$ sudo shutdown -h now</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"2-在主机上的操作\"><a href=\"#2-在主机上的操作\" class=\"headerlink\" title=\"2.在主机上的操作\"></a>2.在主机上的操作</h5><ul>\n<li><p>清除VM镜像中的MAC地址相关的信息</p>\n<blockquote>\n<p> $ sudo virt-sysprep -d <strong>VM</strong></p>\n</blockquote>\n</li>\n<li><p>删除主机中的<strong>VM</strong>虚拟机定义</p>\n<blockquote>\n<p>$ sudo virsh undefine <strong>VM</strong></p>\n</blockquote>\n</li>\n<li><p>上传镜像至<strong>Glance</strong>服务</p>\n<blockquote>\n<p>$ glance image-create –name “<strong>VM-templet</strong>“ –file  <strong>VM.img</strong> –disk-format <strong>qcow2</strong> –container-format bare –visibility public –progress</p>\n</blockquote>\n</li>\n</ul>\n<h5 id=\"Done\"><a href=\"#Done\" class=\"headerlink\" title=\"Done!\"></a>Done!</h5>"},{"title":"使用Guestfish给虚拟磁盘扩容","date":"2016-10-11T12:09:51.000Z","_content":"\n##### 问题背景：\n使用openstack dashboard 创建虚拟机时，有时创建虚拟机会出现如下错误\n\n  >**Error: Flavor's disk is too small for requested image**\n\n>   这种情况是由于flavor的配置不够导致的，将flavor的配置弄好后，再次创建，出现以下错误： **No Space Left To Write**, 这是因为我只有一个compute1节点，而且磁盘只有10G，但我创建的分配给实例的是20G。\n\n *  我们知道openstack的实例时创建在**compute节点**的**/var/lib/nova/instances/**里的，再挂载一块磁盘到这个目录显然不是一个很好的解决方式，最好是直接给compute节点的硬盘扩容，本文采用**Guestfish**给虚拟磁盘扩容。\n\n1.安装**Guestfish**\n> $ sudo apt-get install libguestfs-tools\n\n2.查看虚拟硬盘分区表\n>  $ sudo virt-filesystems --long --parts --blkdevs -h -a VM.img\n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   9.7G   /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    11G    -   \n  那么，**/dev/sda1** 就是我们要扩容的分区\n\n3.创建一个更大的磁盘文件\n  >磁盘文件格式与之前的虚拟磁盘格式保持一致\n\n> $ qemu-img create -f qcow2 new_disk.qcow2 50G \n\n>     Formatting 'new_disk.qcow2', fmt=qcow2 size=53687091200 encryption=off \n    cluster_size=65536 lazy_refcounts=off\n\n\n4.使用guestfish中的virt-*命令进行扩容\n > $ virt-resize --expand /dev/sda1 VM.img new_disk.qcow2 \n\n>     Examining VM.img ...\n    **********\n    Summary of changes:\n    /dev/sda1: This partition will be resized from 9.7G to 49.0G.  The \n    filesystem ext4 on /dev/sda1 will be expanded using the 'resize2fs' \n    method.\n    /dev/sda2: This partition will be left alone.\n    **********  \n    Setting up initial partition table on com.qcow2 ...\n    Copying /dev/sda1 ...\n    ...\n    $<2> 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\n    Copying /dev/sda2 ...\n    ...\n    $<2> 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\n    Expanding /dev/sda1 using the 'resize2fs' method ...\n    Resize operation completed with no errors.  Before deleting the old disk,\n    carefully check that the resized disk boots and works correctly.\n\n5.查看分区表\n>$  sudo virt-filesystems --long --parts --blkdevs -h -a new_disk.qcow2\n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   49G    /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    50G    -\n\n>$ virt-filesystems --long --parts --blkdevs -h -a VM.img \n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   9.7G   /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    11G    -\n此时，源磁盘VM.img里面的文件系统已经完整的被拷贝到new_disk.qcow2\n\n 5.删除源磁盘，并将new_disk.qcow2 改名为 VM.img\n> $ sudo rm VM.img \n> $ sudo mv new_disk.qcow2 VM.img\n\n###### DONE！\n","source":"_posts/使用Guestfish给虚拟磁盘扩容.md","raw":"---\ntitle: 使用Guestfish给虚拟磁盘扩容\ndate: 2016-10-11 05:09:51\ntags:\n - Linux\n - GuestFish\n---\n\n##### 问题背景：\n使用openstack dashboard 创建虚拟机时，有时创建虚拟机会出现如下错误\n\n  >**Error: Flavor's disk is too small for requested image**\n\n>   这种情况是由于flavor的配置不够导致的，将flavor的配置弄好后，再次创建，出现以下错误： **No Space Left To Write**, 这是因为我只有一个compute1节点，而且磁盘只有10G，但我创建的分配给实例的是20G。\n\n *  我们知道openstack的实例时创建在**compute节点**的**/var/lib/nova/instances/**里的，再挂载一块磁盘到这个目录显然不是一个很好的解决方式，最好是直接给compute节点的硬盘扩容，本文采用**Guestfish**给虚拟磁盘扩容。\n\n1.安装**Guestfish**\n> $ sudo apt-get install libguestfs-tools\n\n2.查看虚拟硬盘分区表\n>  $ sudo virt-filesystems --long --parts --blkdevs -h -a VM.img\n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   9.7G   /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    11G    -   \n  那么，**/dev/sda1** 就是我们要扩容的分区\n\n3.创建一个更大的磁盘文件\n  >磁盘文件格式与之前的虚拟磁盘格式保持一致\n\n> $ qemu-img create -f qcow2 new_disk.qcow2 50G \n\n>     Formatting 'new_disk.qcow2', fmt=qcow2 size=53687091200 encryption=off \n    cluster_size=65536 lazy_refcounts=off\n\n\n4.使用guestfish中的virt-*命令进行扩容\n > $ virt-resize --expand /dev/sda1 VM.img new_disk.qcow2 \n\n>     Examining VM.img ...\n    **********\n    Summary of changes:\n    /dev/sda1: This partition will be resized from 9.7G to 49.0G.  The \n    filesystem ext4 on /dev/sda1 will be expanded using the 'resize2fs' \n    method.\n    /dev/sda2: This partition will be left alone.\n    **********  \n    Setting up initial partition table on com.qcow2 ...\n    Copying /dev/sda1 ...\n    ...\n    $<2> 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\n    Copying /dev/sda2 ...\n    ...\n    $<2> 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\n    Expanding /dev/sda1 using the 'resize2fs' method ...\n    Resize operation completed with no errors.  Before deleting the old disk,\n    carefully check that the resized disk boots and works correctly.\n\n5.查看分区表\n>$  sudo virt-filesystems --long --parts --blkdevs -h -a new_disk.qcow2\n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   49G    /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    50G    -\n\n>$ virt-filesystems --long --parts --blkdevs -h -a VM.img \n\n>     Name       Type       MBR  Size   Parent\n    /dev/sda1  partition  83   9.7G   /dev/sda\n    /dev/sda2  partition  05   1.0K   /dev/sda\n    /dev/sda5  partition  82   1022M  /dev/sda\n    /dev/sda   device     -    11G    -\n此时，源磁盘VM.img里面的文件系统已经完整的被拷贝到new_disk.qcow2\n\n 5.删除源磁盘，并将new_disk.qcow2 改名为 VM.img\n> $ sudo rm VM.img \n> $ sudo mv new_disk.qcow2 VM.img\n\n###### DONE！\n","slug":"使用Guestfish给虚拟磁盘扩容","published":1,"updated":"2017-05-15T12:18:03.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r0x0009mqjxdc4hzd25","content":"<h5 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a>问题背景：</h5><p>使用openstack dashboard 创建虚拟机时，有时创建虚拟机会出现如下错误</p>\n<blockquote>\n<p><strong>Error: Flavor’s disk is too small for requested image</strong></p>\n<p>  这种情况是由于flavor的配置不够导致的，将flavor的配置弄好后，再次创建，出现以下错误： <strong>No Space Left To Write</strong>, 这是因为我只有一个compute1节点，而且磁盘只有10G，但我创建的分配给实例的是20G。</p>\n</blockquote>\n<ul>\n<li>我们知道openstack的实例时创建在<strong>compute节点</strong>的<strong>/var/lib/nova/instances/</strong>里的，再挂载一块磁盘到这个目录显然不是一个很好的解决方式，最好是直接给compute节点的硬盘扩容，本文采用<strong>Guestfish</strong>给虚拟磁盘扩容。</li>\n</ul>\n<p>1.安装<strong>Guestfish</strong></p>\n<blockquote>\n<p>$ sudo apt-get install libguestfs-tools</p>\n</blockquote>\n<p>2.查看虚拟硬盘分区表</p>\n<blockquote>\n<p> $ sudo virt-filesystems –long –parts –blkdevs -h -a VM.img</p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   9.7G   /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    11G    -   \n</code></pre><p>  那么，<strong>/dev/sda1</strong> 就是我们要扩容的分区</p>\n</blockquote>\n<p>3.创建一个更大的磁盘文件</p>\n<blockquote>\n<p>磁盘文件格式与之前的虚拟磁盘格式保持一致</p>\n<p>$ qemu-img create -f qcow2 new_disk.qcow2 50G </p>\n<pre><code>Formatting &apos;new_disk.qcow2&apos;, fmt=qcow2 size=53687091200 encryption=off \ncluster_size=65536 lazy_refcounts=off\n</code></pre></blockquote>\n<p>4.使用guestfish中的virt-*命令进行扩容</p>\n<blockquote>\n<p>$ virt-resize –expand /dev/sda1 VM.img new_disk.qcow2 </p>\n<pre><code>Examining VM.img ...\n**********\nSummary of changes:\n/dev/sda1: This partition will be resized from 9.7G to 49.0G.  The \nfilesystem ext4 on /dev/sda1 will be expanded using the &apos;resize2fs&apos; \nmethod.\n/dev/sda2: This partition will be left alone.\n**********  \nSetting up initial partition table on com.qcow2 ...\nCopying /dev/sda1 ...\n...\n$&lt;2&gt; 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\nCopying /dev/sda2 ...\n...\n$&lt;2&gt; 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\nExpanding /dev/sda1 using the &apos;resize2fs&apos; method ...\nResize operation completed with no errors.  Before deleting the old disk,\ncarefully check that the resized disk boots and works correctly.\n</code></pre></blockquote>\n<p>5.查看分区表</p>\n<blockquote>\n<p>$  sudo virt-filesystems –long –parts –blkdevs -h -a new_disk.qcow2</p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   49G    /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    50G    -\n</code></pre><p>$ virt-filesystems –long –parts –blkdevs -h -a VM.img </p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   9.7G   /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    11G    -\n</code></pre><p>此时，源磁盘VM.img里面的文件系统已经完整的被拷贝到new_disk.qcow2</p>\n</blockquote>\n<p> 5.删除源磁盘，并将new_disk.qcow2 改名为 VM.img</p>\n<blockquote>\n<p>$ sudo rm VM.img<br>$ sudo mv new_disk.qcow2 VM.img</p>\n</blockquote>\n<h6 id=\"DONE！\"><a href=\"#DONE！\" class=\"headerlink\" title=\"DONE！\"></a>DONE！</h6>","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h5 id=\"问题背景：\"><a href=\"#问题背景：\" class=\"headerlink\" title=\"问题背景：\"></a>问题背景：</h5><p>使用openstack dashboard 创建虚拟机时，有时创建虚拟机会出现如下错误</p>\n<blockquote>\n<p><strong>Error: Flavor’s disk is too small for requested image</strong></p>\n<p>  这种情况是由于flavor的配置不够导致的，将flavor的配置弄好后，再次创建，出现以下错误： <strong>No Space Left To Write</strong>, 这是因为我只有一个compute1节点，而且磁盘只有10G，但我创建的分配给实例的是20G。</p>\n</blockquote>\n<ul>\n<li>我们知道openstack的实例时创建在<strong>compute节点</strong>的<strong>/var/lib/nova/instances/</strong>里的，再挂载一块磁盘到这个目录显然不是一个很好的解决方式，最好是直接给compute节点的硬盘扩容，本文采用<strong>Guestfish</strong>给虚拟磁盘扩容。</li>\n</ul>\n<p>1.安装<strong>Guestfish</strong></p>\n<blockquote>\n<p>$ sudo apt-get install libguestfs-tools</p>\n</blockquote>\n<p>2.查看虚拟硬盘分区表</p>\n<blockquote>\n<p> $ sudo virt-filesystems –long –parts –blkdevs -h -a VM.img</p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   9.7G   /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    11G    -   \n</code></pre><p>  那么，<strong>/dev/sda1</strong> 就是我们要扩容的分区</p>\n</blockquote>\n<p>3.创建一个更大的磁盘文件</p>\n<blockquote>\n<p>磁盘文件格式与之前的虚拟磁盘格式保持一致</p>\n<p>$ qemu-img create -f qcow2 new_disk.qcow2 50G </p>\n<pre><code>Formatting &apos;new_disk.qcow2&apos;, fmt=qcow2 size=53687091200 encryption=off \ncluster_size=65536 lazy_refcounts=off\n</code></pre></blockquote>\n<p>4.使用guestfish中的virt-*命令进行扩容</p>\n<blockquote>\n<p>$ virt-resize –expand /dev/sda1 VM.img new_disk.qcow2 </p>\n<pre><code>Examining VM.img ...\n**********\nSummary of changes:\n/dev/sda1: This partition will be resized from 9.7G to 49.0G.  The \nfilesystem ext4 on /dev/sda1 will be expanded using the &apos;resize2fs&apos; \nmethod.\n/dev/sda2: This partition will be left alone.\n**********  \nSetting up initial partition table on com.qcow2 ...\nCopying /dev/sda1 ...\n...\n$&lt;2&gt; 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\nCopying /dev/sda2 ...\n...\n$&lt;2&gt; 100% ⟦▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒⟧ 00:00\nExpanding /dev/sda1 using the &apos;resize2fs&apos; method ...\nResize operation completed with no errors.  Before deleting the old disk,\ncarefully check that the resized disk boots and works correctly.\n</code></pre></blockquote>\n<p>5.查看分区表</p>\n<blockquote>\n<p>$  sudo virt-filesystems –long –parts –blkdevs -h -a new_disk.qcow2</p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   49G    /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    50G    -\n</code></pre><p>$ virt-filesystems –long –parts –blkdevs -h -a VM.img </p>\n<pre><code>Name       Type       MBR  Size   Parent\n/dev/sda1  partition  83   9.7G   /dev/sda\n/dev/sda2  partition  05   1.0K   /dev/sda\n/dev/sda5  partition  82   1022M  /dev/sda\n/dev/sda   device     -    11G    -\n</code></pre><p>此时，源磁盘VM.img里面的文件系统已经完整的被拷贝到new_disk.qcow2</p>\n</blockquote>\n<p> 5.删除源磁盘，并将new_disk.qcow2 改名为 VM.img</p>\n<blockquote>\n<p>$ sudo rm VM.img<br>$ sudo mv new_disk.qcow2 VM.img</p>\n</blockquote>\n<h6 id=\"DONE！\"><a href=\"#DONE！\" class=\"headerlink\" title=\"DONE！\"></a>DONE！</h6>"},{"layout":"post","title":"Archipel 安装与配置","date":"2016-01-26T13:13:34.000Z","_content":"\n\nArchipel 是一个管理和监督虚拟机的开源解决方案。->[项目主页](http://archipelproject.org/)  ->[GitHub地址](https://github.com/ArchipelProject/Archipel/wiki) \n\n\n\n![Architecture](https://camo.githubusercontent.com/18ac0e081edc75385b0ab4368455e2123961b6b6/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f323636333535322f417263686970656c2532302d25323050726f64756374696f6e2f57696b692f4172636869746563747572652f7468756d626e61696c732f61726368692e706e67)\n\n Archipel Agent　--即上图的Physical Hypervisor 安装在每台物理机上\n Archipel Client　--即上图的Archipel GUI，安装在任意一台linux电脑上\n\n###一. Ejabberd XMPP 服务器端的配置安装\n\nArchipel\n\nXMPP服务器的域名就是本机的hostname, 我的hostname是　alecyrus.org , 这个可与通过命令\" # hostname\"得到，一般默认是ubuntu,　如果需要修改，可运行以下命令，别忘了之后在/etc/hosts 文件中，172.0.1.1 后在ubuntu后并列添加YourHostname，否则无法修改成功.\n  \n    # hostname YourHostname\n    # echo YourHostname > /etc/hostname\n\n1：安装ejabberd(至少15.04版本)\n    \n    # echo \"deb https://apt.jabber.at trusty ejabberd\" > /etc/apt/sources.list.d/jabber.at.list\n    # wget -qO- https://apt.jabber.at/gpg-key | apt-key add -\n    # apt-get update\n    # apt-get install ejabberd\n\n注：我是在ejabberd15.04版本下测试的，deb安装或者installer安装都行。两种方式安装后，打开关闭重启ejabberd服务的操作略有区别。具体查看[ejabberd官方文档](docs.ejabberd.im/admin/guide/installation/)如果安装后使用命令开启ejabberd服务时报错，诸如Failed RPC connection... File Operate Error... 说明ejabberd安装出错，自行查看log解决。\n   \n2：安装必需的依赖包(ArchipelAgent也需要安装这些依赖包)\n    # apt-get install -y git  build-essential qemu-kvm libvirt-bin libvirt-dev python-setuptools python-numpy python-imaging python-apscheduler python-sqlalchemy python-libvirt subversion python-dev\n\n３：配置Ejabberd\n    老版本是ejabberd.cfg, 现在的版本都是yaml配置文件(ejabberd.yml)。\n   如下：\n     \n    ###\n    ###             ejabberd configuration file\n    ###         Archipel Sample default condiguration\n \n    ###     =========================================\n    ###     DEBUGGING\n \n    \n    loglevel: 4\n \n    ###     =========================================\n    ###     SERVED HOSTNAMES\n\n    hosts:\n        - \"alecyrus.org\"\n \n    ###     =========================================\n    ###     LISTENING PORTS\n \n    listen:\n    -\n     \n      port: 4560\n      module: ejabberd_xmlrpc\n      access_commands:\n            xmlrpcaccess:\n                all : []\n \n    ## ejabberd c2s\n    -\n      port: 5222\n      module: ejabberd_c2s\n      max_stanza_size: 65536000\n      shaper: c2s_shaper\n      access: c2s\n \n    ## ejabbed s2s\n    -\n      port: 5269\n      module: ejabberd_s2s_in\n      max_stanza_size: 65536000\n \n    -\n      port: 5280\n      module: ejabberd_http\n      request_handlers:\n        \"/xmpp\": ejabberd_http_ws\n      web_admin: true\n      http_bind: true\n \n    ###     ========================================\n    ###     S2S\n    s2s_policy: s2s_access\n    s2s_use_starttls: optional\n \n\n    ###     =========================================\n    ###     AUTHENTICATION\n \n    auth_method: internal\n \n    ###     =========================================\n    ###     TRAFFIC SHAPERS\n \n    shaper:\n      # in B/s\n      normal: 1000\n      fast: 50000000\n \n    ###     =========================================\n    ###     ACCESS CONTROL LISTS\n \n    acl:\n    admin:\n        user:\n            - \"admin\": \"alecyrus.org\"\n    local:\n        user_regexp: \"\"\n \n \n    ###     =========================================\n    ###     ACCESS RULES\n \n    access:\n    max_user_sessions:\n        all: 10\n    local:\n        local: allow\n    c2s:\n        blocked: deny\n        all: allow\n    c2s_shaper:        \n        admin: none\n        all: fast\n    s2s_shaper:\n        all: fast\n    s2s_access:\n        all: allow\n    announce:\n        admin: allow\n    configure:\n        admin: allow\n    muc_admin:\n        admin: allow\n    muc_create:\n        local: allow\n    muc:\n        all: allow\n    pubsub_createnode:\n        all: allow\n    register:\n        all: allow\n    xmlrpcaccess:\n        admin : allow\n\n    registration_timeout: infinity\n \n    ###     ========================================\n    ###     DEFAULT LANGUAGE\n \n    language: \"en\"\n \n    ###     ========================================\n    ###     MODULES\n \n    modules:\n      mod_admin_extra: []\n      mod_adhoc: []\n      mod_announce:\n        access: announce\n      mod_caps: []\n      mod_configure: []\n      mod_disco: []\n      mod_http_bind:\n        max_inactivity: 400 \n      mod_irc: []\n      mod_last: []\n      mod_muc:\n        access: muc\n        access_create: muc_create\n        access_persistent: muc_create\n        access_admin: muc_admin\n      mod_offline: []\n      mod_privacy: []\n      mod_private: []\n      mod_pubsub:\n        access_createnode: pubsub_createnode\n        ignore_pep_from_offline: true\n        last_item_cache: false\n        max_items_node: 1000\n        plugins:\n            - \"flat\"\n            - \"hometree\"\n            - \"pep\"\n      mod_register:\n        access: register\n      mod_roster: []\n      mod_shared_roster: []\n      mod_time: []\n      mod_vcard: []\n      mod_version: []\n\n\n然后重启ejabberd服务(DEB安装方式)，如果是installer安装，桌面上有俩快捷方式，若没有，进入ejabberd安装目录/bin/, 运行相关命令即可\n\n    # /etc/init.d/ejabberd restart\n\n\n    注：如果重启不成功，使用以下命令来查看启动服务过程中是哪里出问题，一般都是配置文档\n    出错，语法，模块错误什么的。\n\n    # ejabberdctl live\n4：ejabberd xmpp服务器admin账户的注册(DEB安装方式，若是install方式，在安装ejabberd时就创建好了)\n    \n    # ejabberdctl register admin alecyrus.org YourPassWd\n\n####二. Archipel Agent的配置安装\n  Archipel Agent是需要安装在每台物理机上,物理机上的Virtual Machine Monitor 可以是KVM、Xen、VMware... ,以后如果需要把某台物理机上的全部KVM虚拟机添加到Archipel,那就需要在这台物理机上安装Archipel Agent.\n\n前提：能够正常创建虚拟机，qumu，kvm这些的安装好。\n\n１：下载Archipel以及安装\n    \n    # git clone https://github.com/ArchipelProject/Archipel.git\n    # cd Archipel\n    # ./pull.sh\n    # easy_install apscheduler sqlalchemy numpy\n    # cd ArchipelAgent\n    # ./buildAgent -d\n    # archipel-initinstall\n注：通常在archipel-initinstall加上 -x FQDN(# archipel-initinstall -x   alecyrus.org), 意思就是指定这台Physical Hypervisor将要连接的XMPP服务  器  的地址，如果你XMPP服务器和Physical Hypervisor安装在同一台机器上，比如现在，那么Physical Hypervisor 中Archipel的配置没问题，同一台机器，Physical Hypervisor 和XMPP服务器当然能够互相ping通。\n  但是如果以后XMPP服务器配置好了，你想把其他的Physical Hypervisor 添加到XMPP服务器上让ArchipelClient一并管理，如果还是如此配置，那么这台Physical Hypervisor 就无法识别alecyrus.org, 所以在其他机器安装ArchipelAgent，别忘了在hosts文件中添加alecyrus.org 和XMPP服务器ip的映射。同时，保证XMPP服务器与Physical Hypervisor 能相互ping通。\n\n２：将这台Physical Hypervisor 的ArchipelAgent初始化到XMPP服务器，使用你的XMPP服务器的管理员账号。\n    # archipel-tagnode -j admin@alecyrus.org -p  YourPassWD --create\n    # archipel-rolesnode -j admin@alecyrus.org -p YourPassWD --create\n    # archipel-adminaccounts -j admin@alecyrus.org -p YourPassWD --create\n\n\n\n3：配置Archipel Agent\n\n编辑/etc/archipel.conf, 添加以下内容\n \n    [MODULES]\n \n    action_scheduler            = True\n    centraldb                   = True\n    geolocalization             = True\n    hypervisor_health           = True\n    hypervisor_network          = True\n    hypervisor_vmcasts          = True\n    iphone_notification         = False\n    oomkiller                   = True\n    snapshoting                 = True\n    storage                     = True\n    virtualmachine_appliance    = True\n    vnc                         = True\n    xmppserver                  = True\n    vmparking                   = True  # needs centraldb to be     activated\n \n    [CENTRALAGENT]\n    # centralagent can be :\n    #  - auto (default) : will be central agent if there is none already started\n    #  - force : will be central agent (be careful to configure only one of your hypervisors this way)\n    centralagent               = auto\n \n    [VNC]\n    vnc_certificate_file                        = None\n    vnc_only_ssl                                = False\n    vnc_enable_websocket_debug                  = True\n\n注：最后将machine_ip由auto改成这台hypervisor的ip地址，这样方便archipel查看ip地址。\n\n4:重启Archipel\n\n     # /etc/init.d/archipel restart\n\n\n####三. Archipel Client安装　\n  Archipel Client就是一个web应用，通过官方发布的The nightlies版本可以很方便的安装的，但经过测试(Ubuntu 14.04LTS)，项目作者把centralAgent也加入admin list后，centralAgent就无法正常安装了，bu\n以下命令在之前clone命令的同级目录下进行，即开始这条命令时，ls命令可以可以看到之前的Archipel文件夹。\n \n    # wget http://nightlies.archipelproject.org/latest-archipel-client.tar.gz\n    # tar -xzf latest-archipel-client.tar.gz\n  \n\n\n\n####四. 最后的工作\n\n进入Archipel目录开启HTTP服务\n\n  １：开启8000端口\n\n    # python -m SimpleHTTPServer\n\n    注:务必进入Archipel目录运行这个命令\n２：\n    打开网址：localhost:8000\n![](http://upload-images.jianshu.io/upload_images/1113810-0d5a0c620f259122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    \n登陆信息如上\n然后添加安装了Archipel Agent的Physical Hypervisor　的JID...\n\n这个JID的格式可以在archipel.conf 中看到。。如下：\n\n我这里是alecyrus@%(xmpp_server)s，，也就是说JID为：\nalecyrus@alecyrus.org\n![](http://upload-images.jianshu.io/upload_images/1113810-fa23335e07986c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![2016-01-18 02:04:30屏幕截图.png](http://upload-images.jianshu.io/upload_images/1113810-791ee902e581d2d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n添加完成后，就可以在这里看到你的物理机的虚拟机管理程序了，不过它变了样子\n\n![2016-01-18 02:14:08屏幕截图.png](http://upload-images.jianshu.io/upload_images/1113810-aa4593d21dae1b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n一个Physical Hypervisor就是你的一个联系人，这个联系人下面可以有很多的虚拟机，你也可以把虚拟机添加联系人中。\n\nDone！\n","source":"_posts/安装与配置.md","raw":"---\nlayout: post\ntitle: Archipel 安装与配置\ndate: 2016-01-26 05:13:34\ntags:\n - Archipel\n---\n\n\nArchipel 是一个管理和监督虚拟机的开源解决方案。->[项目主页](http://archipelproject.org/)  ->[GitHub地址](https://github.com/ArchipelProject/Archipel/wiki) \n\n\n\n![Architecture](https://camo.githubusercontent.com/18ac0e081edc75385b0ab4368455e2123961b6b6/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f323636333535322f417263686970656c2532302d25323050726f64756374696f6e2f57696b692f4172636869746563747572652f7468756d626e61696c732f61726368692e706e67)\n\n Archipel Agent　--即上图的Physical Hypervisor 安装在每台物理机上\n Archipel Client　--即上图的Archipel GUI，安装在任意一台linux电脑上\n\n###一. Ejabberd XMPP 服务器端的配置安装\n\nArchipel\n\nXMPP服务器的域名就是本机的hostname, 我的hostname是　alecyrus.org , 这个可与通过命令\" # hostname\"得到，一般默认是ubuntu,　如果需要修改，可运行以下命令，别忘了之后在/etc/hosts 文件中，172.0.1.1 后在ubuntu后并列添加YourHostname，否则无法修改成功.\n  \n    # hostname YourHostname\n    # echo YourHostname > /etc/hostname\n\n1：安装ejabberd(至少15.04版本)\n    \n    # echo \"deb https://apt.jabber.at trusty ejabberd\" > /etc/apt/sources.list.d/jabber.at.list\n    # wget -qO- https://apt.jabber.at/gpg-key | apt-key add -\n    # apt-get update\n    # apt-get install ejabberd\n\n注：我是在ejabberd15.04版本下测试的，deb安装或者installer安装都行。两种方式安装后，打开关闭重启ejabberd服务的操作略有区别。具体查看[ejabberd官方文档](docs.ejabberd.im/admin/guide/installation/)如果安装后使用命令开启ejabberd服务时报错，诸如Failed RPC connection... File Operate Error... 说明ejabberd安装出错，自行查看log解决。\n   \n2：安装必需的依赖包(ArchipelAgent也需要安装这些依赖包)\n    # apt-get install -y git  build-essential qemu-kvm libvirt-bin libvirt-dev python-setuptools python-numpy python-imaging python-apscheduler python-sqlalchemy python-libvirt subversion python-dev\n\n３：配置Ejabberd\n    老版本是ejabberd.cfg, 现在的版本都是yaml配置文件(ejabberd.yml)。\n   如下：\n     \n    ###\n    ###             ejabberd configuration file\n    ###         Archipel Sample default condiguration\n \n    ###     =========================================\n    ###     DEBUGGING\n \n    \n    loglevel: 4\n \n    ###     =========================================\n    ###     SERVED HOSTNAMES\n\n    hosts:\n        - \"alecyrus.org\"\n \n    ###     =========================================\n    ###     LISTENING PORTS\n \n    listen:\n    -\n     \n      port: 4560\n      module: ejabberd_xmlrpc\n      access_commands:\n            xmlrpcaccess:\n                all : []\n \n    ## ejabberd c2s\n    -\n      port: 5222\n      module: ejabberd_c2s\n      max_stanza_size: 65536000\n      shaper: c2s_shaper\n      access: c2s\n \n    ## ejabbed s2s\n    -\n      port: 5269\n      module: ejabberd_s2s_in\n      max_stanza_size: 65536000\n \n    -\n      port: 5280\n      module: ejabberd_http\n      request_handlers:\n        \"/xmpp\": ejabberd_http_ws\n      web_admin: true\n      http_bind: true\n \n    ###     ========================================\n    ###     S2S\n    s2s_policy: s2s_access\n    s2s_use_starttls: optional\n \n\n    ###     =========================================\n    ###     AUTHENTICATION\n \n    auth_method: internal\n \n    ###     =========================================\n    ###     TRAFFIC SHAPERS\n \n    shaper:\n      # in B/s\n      normal: 1000\n      fast: 50000000\n \n    ###     =========================================\n    ###     ACCESS CONTROL LISTS\n \n    acl:\n    admin:\n        user:\n            - \"admin\": \"alecyrus.org\"\n    local:\n        user_regexp: \"\"\n \n \n    ###     =========================================\n    ###     ACCESS RULES\n \n    access:\n    max_user_sessions:\n        all: 10\n    local:\n        local: allow\n    c2s:\n        blocked: deny\n        all: allow\n    c2s_shaper:        \n        admin: none\n        all: fast\n    s2s_shaper:\n        all: fast\n    s2s_access:\n        all: allow\n    announce:\n        admin: allow\n    configure:\n        admin: allow\n    muc_admin:\n        admin: allow\n    muc_create:\n        local: allow\n    muc:\n        all: allow\n    pubsub_createnode:\n        all: allow\n    register:\n        all: allow\n    xmlrpcaccess:\n        admin : allow\n\n    registration_timeout: infinity\n \n    ###     ========================================\n    ###     DEFAULT LANGUAGE\n \n    language: \"en\"\n \n    ###     ========================================\n    ###     MODULES\n \n    modules:\n      mod_admin_extra: []\n      mod_adhoc: []\n      mod_announce:\n        access: announce\n      mod_caps: []\n      mod_configure: []\n      mod_disco: []\n      mod_http_bind:\n        max_inactivity: 400 \n      mod_irc: []\n      mod_last: []\n      mod_muc:\n        access: muc\n        access_create: muc_create\n        access_persistent: muc_create\n        access_admin: muc_admin\n      mod_offline: []\n      mod_privacy: []\n      mod_private: []\n      mod_pubsub:\n        access_createnode: pubsub_createnode\n        ignore_pep_from_offline: true\n        last_item_cache: false\n        max_items_node: 1000\n        plugins:\n            - \"flat\"\n            - \"hometree\"\n            - \"pep\"\n      mod_register:\n        access: register\n      mod_roster: []\n      mod_shared_roster: []\n      mod_time: []\n      mod_vcard: []\n      mod_version: []\n\n\n然后重启ejabberd服务(DEB安装方式)，如果是installer安装，桌面上有俩快捷方式，若没有，进入ejabberd安装目录/bin/, 运行相关命令即可\n\n    # /etc/init.d/ejabberd restart\n\n\n    注：如果重启不成功，使用以下命令来查看启动服务过程中是哪里出问题，一般都是配置文档\n    出错，语法，模块错误什么的。\n\n    # ejabberdctl live\n4：ejabberd xmpp服务器admin账户的注册(DEB安装方式，若是install方式，在安装ejabberd时就创建好了)\n    \n    # ejabberdctl register admin alecyrus.org YourPassWd\n\n####二. Archipel Agent的配置安装\n  Archipel Agent是需要安装在每台物理机上,物理机上的Virtual Machine Monitor 可以是KVM、Xen、VMware... ,以后如果需要把某台物理机上的全部KVM虚拟机添加到Archipel,那就需要在这台物理机上安装Archipel Agent.\n\n前提：能够正常创建虚拟机，qumu，kvm这些的安装好。\n\n１：下载Archipel以及安装\n    \n    # git clone https://github.com/ArchipelProject/Archipel.git\n    # cd Archipel\n    # ./pull.sh\n    # easy_install apscheduler sqlalchemy numpy\n    # cd ArchipelAgent\n    # ./buildAgent -d\n    # archipel-initinstall\n注：通常在archipel-initinstall加上 -x FQDN(# archipel-initinstall -x   alecyrus.org), 意思就是指定这台Physical Hypervisor将要连接的XMPP服务  器  的地址，如果你XMPP服务器和Physical Hypervisor安装在同一台机器上，比如现在，那么Physical Hypervisor 中Archipel的配置没问题，同一台机器，Physical Hypervisor 和XMPP服务器当然能够互相ping通。\n  但是如果以后XMPP服务器配置好了，你想把其他的Physical Hypervisor 添加到XMPP服务器上让ArchipelClient一并管理，如果还是如此配置，那么这台Physical Hypervisor 就无法识别alecyrus.org, 所以在其他机器安装ArchipelAgent，别忘了在hosts文件中添加alecyrus.org 和XMPP服务器ip的映射。同时，保证XMPP服务器与Physical Hypervisor 能相互ping通。\n\n２：将这台Physical Hypervisor 的ArchipelAgent初始化到XMPP服务器，使用你的XMPP服务器的管理员账号。\n    # archipel-tagnode -j admin@alecyrus.org -p  YourPassWD --create\n    # archipel-rolesnode -j admin@alecyrus.org -p YourPassWD --create\n    # archipel-adminaccounts -j admin@alecyrus.org -p YourPassWD --create\n\n\n\n3：配置Archipel Agent\n\n编辑/etc/archipel.conf, 添加以下内容\n \n    [MODULES]\n \n    action_scheduler            = True\n    centraldb                   = True\n    geolocalization             = True\n    hypervisor_health           = True\n    hypervisor_network          = True\n    hypervisor_vmcasts          = True\n    iphone_notification         = False\n    oomkiller                   = True\n    snapshoting                 = True\n    storage                     = True\n    virtualmachine_appliance    = True\n    vnc                         = True\n    xmppserver                  = True\n    vmparking                   = True  # needs centraldb to be     activated\n \n    [CENTRALAGENT]\n    # centralagent can be :\n    #  - auto (default) : will be central agent if there is none already started\n    #  - force : will be central agent (be careful to configure only one of your hypervisors this way)\n    centralagent               = auto\n \n    [VNC]\n    vnc_certificate_file                        = None\n    vnc_only_ssl                                = False\n    vnc_enable_websocket_debug                  = True\n\n注：最后将machine_ip由auto改成这台hypervisor的ip地址，这样方便archipel查看ip地址。\n\n4:重启Archipel\n\n     # /etc/init.d/archipel restart\n\n\n####三. Archipel Client安装　\n  Archipel Client就是一个web应用，通过官方发布的The nightlies版本可以很方便的安装的，但经过测试(Ubuntu 14.04LTS)，项目作者把centralAgent也加入admin list后，centralAgent就无法正常安装了，bu\n以下命令在之前clone命令的同级目录下进行，即开始这条命令时，ls命令可以可以看到之前的Archipel文件夹。\n \n    # wget http://nightlies.archipelproject.org/latest-archipel-client.tar.gz\n    # tar -xzf latest-archipel-client.tar.gz\n  \n\n\n\n####四. 最后的工作\n\n进入Archipel目录开启HTTP服务\n\n  １：开启8000端口\n\n    # python -m SimpleHTTPServer\n\n    注:务必进入Archipel目录运行这个命令\n２：\n    打开网址：localhost:8000\n![](http://upload-images.jianshu.io/upload_images/1113810-0d5a0c620f259122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n    \n登陆信息如上\n然后添加安装了Archipel Agent的Physical Hypervisor　的JID...\n\n这个JID的格式可以在archipel.conf 中看到。。如下：\n\n我这里是alecyrus@%(xmpp_server)s，，也就是说JID为：\nalecyrus@alecyrus.org\n![](http://upload-images.jianshu.io/upload_images/1113810-fa23335e07986c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![2016-01-18 02:04:30屏幕截图.png](http://upload-images.jianshu.io/upload_images/1113810-791ee902e581d2d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n添加完成后，就可以在这里看到你的物理机的虚拟机管理程序了，不过它变了样子\n\n![2016-01-18 02:14:08屏幕截图.png](http://upload-images.jianshu.io/upload_images/1113810-aa4593d21dae1b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n  \n一个Physical Hypervisor就是你的一个联系人，这个联系人下面可以有很多的虚拟机，你也可以把虚拟机添加联系人中。\n\nDone！\n","slug":"安装与配置","published":1,"updated":"2017-05-15T12:14:49.908Z","comments":1,"photos":[],"link":"","_id":"cj2qy2r0z000bmqjxb4qd6q2z","content":"<p>Archipel 是一个管理和监督虚拟机的开源解决方案。-&gt;<a href=\"http://archipelproject.org/\" target=\"_blank\" rel=\"external\">项目主页</a>  -&gt;<a href=\"https://github.com/ArchipelProject/Archipel/wiki\" target=\"_blank\" rel=\"external\">GitHub地址</a> </p>\n<p><img src=\"https://camo.githubusercontent.com/18ac0e081edc75385b0ab4368455e2123961b6b6/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f323636333535322f417263686970656c2532302d25323050726f64756374696f6e2f57696b692f4172636869746563747572652f7468756d626e61696c732f61726368692e706e67\" alt=\"Architecture\"></p>\n<p> Archipel Agent　–即上图的Physical Hypervisor 安装在每台物理机上<br> Archipel Client　–即上图的Archipel GUI，安装在任意一台linux电脑上</p>\n<p>###一. Ejabberd XMPP 服务器端的配置安装</p>\n<p>Archipel</p>\n<p>XMPP服务器的域名就是本机的hostname, 我的hostname是　alecyrus.org , 这个可与通过命令” # hostname”得到，一般默认是ubuntu,　如果需要修改，可运行以下命令，别忘了之后在/etc/hosts 文件中，172.0.1.1 后在ubuntu后并列添加YourHostname，否则无法修改成功.</p>\n<pre><code># hostname YourHostname\n# echo YourHostname &gt; /etc/hostname\n</code></pre><p>1：安装ejabberd(至少15.04版本)</p>\n<pre><code># echo &quot;deb https://apt.jabber.at trusty ejabberd&quot; &gt; /etc/apt/sources.list.d/jabber.at.list\n# wget -qO- https://apt.jabber.at/gpg-key | apt-key add -\n# apt-get update\n# apt-get install ejabberd\n</code></pre><p>注：我是在ejabberd15.04版本下测试的，deb安装或者installer安装都行。两种方式安装后，打开关闭重启ejabberd服务的操作略有区别。具体查看<a href=\"docs.ejabberd.im/admin/guide/installation/\">ejabberd官方文档</a>如果安装后使用命令开启ejabberd服务时报错，诸如Failed RPC connection… File Operate Error… 说明ejabberd安装出错，自行查看log解决。</p>\n<p>2：安装必需的依赖包(ArchipelAgent也需要安装这些依赖包)</p>\n<pre><code># apt-get install -y git  build-essential qemu-kvm libvirt-bin libvirt-dev python-setuptools python-numpy python-imaging python-apscheduler python-sqlalchemy python-libvirt subversion python-dev\n</code></pre><p>３：配置Ejabberd<br>    老版本是ejabberd.cfg, 现在的版本都是yaml配置文件(ejabberd.yml)。<br>   如下：</p>\n<pre><code>###\n###             ejabberd configuration file\n###         Archipel Sample default condiguration\n\n###     =========================================\n###     DEBUGGING\n\n\nloglevel: 4\n\n###     =========================================\n###     SERVED HOSTNAMES\n\nhosts:\n    - &quot;alecyrus.org&quot;\n\n###     =========================================\n###     LISTENING PORTS\n\nlisten:\n-\n\n  port: 4560\n  module: ejabberd_xmlrpc\n  access_commands:\n        xmlrpcaccess:\n            all : []\n\n## ejabberd c2s\n-\n  port: 5222\n  module: ejabberd_c2s\n  max_stanza_size: 65536000\n  shaper: c2s_shaper\n  access: c2s\n\n## ejabbed s2s\n-\n  port: 5269\n  module: ejabberd_s2s_in\n  max_stanza_size: 65536000\n\n-\n  port: 5280\n  module: ejabberd_http\n  request_handlers:\n    &quot;/xmpp&quot;: ejabberd_http_ws\n  web_admin: true\n  http_bind: true\n\n###     ========================================\n###     S2S\ns2s_policy: s2s_access\ns2s_use_starttls: optional\n\n\n###     =========================================\n###     AUTHENTICATION\n\nauth_method: internal\n\n###     =========================================\n###     TRAFFIC SHAPERS\n\nshaper:\n  # in B/s\n  normal: 1000\n  fast: 50000000\n\n###     =========================================\n###     ACCESS CONTROL LISTS\n\nacl:\nadmin:\n    user:\n        - &quot;admin&quot;: &quot;alecyrus.org&quot;\nlocal:\n    user_regexp: &quot;&quot;\n\n\n###     =========================================\n###     ACCESS RULES\n\naccess:\nmax_user_sessions:\n    all: 10\nlocal:\n    local: allow\nc2s:\n    blocked: deny\n    all: allow\nc2s_shaper:        \n    admin: none\n    all: fast\ns2s_shaper:\n    all: fast\ns2s_access:\n    all: allow\nannounce:\n    admin: allow\nconfigure:\n    admin: allow\nmuc_admin:\n    admin: allow\nmuc_create:\n    local: allow\nmuc:\n    all: allow\npubsub_createnode:\n    all: allow\nregister:\n    all: allow\nxmlrpcaccess:\n    admin : allow\n\nregistration_timeout: infinity\n\n###     ========================================\n###     DEFAULT LANGUAGE\n\nlanguage: &quot;en&quot;\n\n###     ========================================\n###     MODULES\n\nmodules:\n  mod_admin_extra: []\n  mod_adhoc: []\n  mod_announce:\n    access: announce\n  mod_caps: []\n  mod_configure: []\n  mod_disco: []\n  mod_http_bind:\n    max_inactivity: 400 \n  mod_irc: []\n  mod_last: []\n  mod_muc:\n    access: muc\n    access_create: muc_create\n    access_persistent: muc_create\n    access_admin: muc_admin\n  mod_offline: []\n  mod_privacy: []\n  mod_private: []\n  mod_pubsub:\n    access_createnode: pubsub_createnode\n    ignore_pep_from_offline: true\n    last_item_cache: false\n    max_items_node: 1000\n    plugins:\n        - &quot;flat&quot;\n        - &quot;hometree&quot;\n        - &quot;pep&quot;\n  mod_register:\n    access: register\n  mod_roster: []\n  mod_shared_roster: []\n  mod_time: []\n  mod_vcard: []\n  mod_version: []\n</code></pre><p>然后重启ejabberd服务(DEB安装方式)，如果是installer安装，桌面上有俩快捷方式，若没有，进入ejabberd安装目录/bin/, 运行相关命令即可</p>\n<pre><code># /etc/init.d/ejabberd restart\n\n\n注：如果重启不成功，使用以下命令来查看启动服务过程中是哪里出问题，一般都是配置文档\n出错，语法，模块错误什么的。\n\n# ejabberdctl live\n</code></pre><p>4：ejabberd xmpp服务器admin账户的注册(DEB安装方式，若是install方式，在安装ejabberd时就创建好了)</p>\n<pre><code># ejabberdctl register admin alecyrus.org YourPassWd\n</code></pre><p>####二. Archipel Agent的配置安装<br>  Archipel Agent是需要安装在每台物理机上,物理机上的Virtual Machine Monitor 可以是KVM、Xen、VMware… ,以后如果需要把某台物理机上的全部KVM虚拟机添加到Archipel,那就需要在这台物理机上安装Archipel Agent.</p>\n<p>前提：能够正常创建虚拟机，qumu，kvm这些的安装好。</p>\n<p>１：下载Archipel以及安装</p>\n<pre><code># git clone https://github.com/ArchipelProject/Archipel.git\n# cd Archipel\n# ./pull.sh\n# easy_install apscheduler sqlalchemy numpy\n# cd ArchipelAgent\n# ./buildAgent -d\n# archipel-initinstall\n</code></pre><p>注：通常在archipel-initinstall加上 -x FQDN(# archipel-initinstall -x   alecyrus.org), 意思就是指定这台Physical Hypervisor将要连接的XMPP服务  器  的地址，如果你XMPP服务器和Physical Hypervisor安装在同一台机器上，比如现在，那么Physical Hypervisor 中Archipel的配置没问题，同一台机器，Physical Hypervisor 和XMPP服务器当然能够互相ping通。<br>  但是如果以后XMPP服务器配置好了，你想把其他的Physical Hypervisor 添加到XMPP服务器上让ArchipelClient一并管理，如果还是如此配置，那么这台Physical Hypervisor 就无法识别alecyrus.org, 所以在其他机器安装ArchipelAgent，别忘了在hosts文件中添加alecyrus.org 和XMPP服务器ip的映射。同时，保证XMPP服务器与Physical Hypervisor 能相互ping通。</p>\n<p>２：将这台Physical Hypervisor 的ArchipelAgent初始化到XMPP服务器，使用你的XMPP服务器的管理员账号。</p>\n<pre><code># archipel-tagnode -j admin@alecyrus.org -p  YourPassWD --create\n# archipel-rolesnode -j admin@alecyrus.org -p YourPassWD --create\n# archipel-adminaccounts -j admin@alecyrus.org -p YourPassWD --create\n</code></pre><p>3：配置Archipel Agent</p>\n<p>编辑/etc/archipel.conf, 添加以下内容</p>\n<pre><code>[MODULES]\n\naction_scheduler            = True\ncentraldb                   = True\ngeolocalization             = True\nhypervisor_health           = True\nhypervisor_network          = True\nhypervisor_vmcasts          = True\niphone_notification         = False\noomkiller                   = True\nsnapshoting                 = True\nstorage                     = True\nvirtualmachine_appliance    = True\nvnc                         = True\nxmppserver                  = True\nvmparking                   = True  # needs centraldb to be     activated\n\n[CENTRALAGENT]\n# centralagent can be :\n#  - auto (default) : will be central agent if there is none already started\n#  - force : will be central agent (be careful to configure only one of your hypervisors this way)\ncentralagent               = auto\n\n[VNC]\nvnc_certificate_file                        = None\nvnc_only_ssl                                = False\nvnc_enable_websocket_debug                  = True\n</code></pre><p>注：最后将machine_ip由auto改成这台hypervisor的ip地址，这样方便archipel查看ip地址。</p>\n<p>4:重启Archipel</p>\n<pre><code># /etc/init.d/archipel restart\n</code></pre><p>####三. Archipel Client安装　<br>  Archipel Client就是一个web应用，通过官方发布的The nightlies版本可以很方便的安装的，但经过测试(Ubuntu 14.04LTS)，项目作者把centralAgent也加入admin list后，centralAgent就无法正常安装了，bu<br>以下命令在之前clone命令的同级目录下进行，即开始这条命令时，ls命令可以可以看到之前的Archipel文件夹。</p>\n<pre><code># wget http://nightlies.archipelproject.org/latest-archipel-client.tar.gz\n# tar -xzf latest-archipel-client.tar.gz\n</code></pre><p>####四. 最后的工作</p>\n<p>进入Archipel目录开启HTTP服务</p>\n<p>  １：开启8000端口</p>\n<pre><code># python -m SimpleHTTPServer\n\n注:务必进入Archipel目录运行这个命令\n</code></pre><p>２：<br>    打开网址：localhost:8000<br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-0d5a0c620f259122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>登陆信息如上<br>然后添加安装了Archipel Agent的Physical Hypervisor　的JID…</p>\n<p>这个JID的格式可以在archipel.conf 中看到。。如下：</p>\n<p>我这里是alecyrus@%(xmpp_server)s，，也就是说JID为：<br>alecyrus@alecyrus.org<br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-fa23335e07986c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-791ee902e581d2d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2016-01-18 02:04:30屏幕截图.png\"></p>\n<p>添加完成后，就可以在这里看到你的物理机的虚拟机管理程序了，不过它变了样子</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-aa4593d21dae1b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2016-01-18 02:14:08屏幕截图.png\"></p>\n<p>一个Physical Hypervisor就是你的一个联系人，这个联系人下面可以有很多的虚拟机，你也可以把虚拟机添加联系人中。</p>\n<p>Done！</p>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<p>Archipel 是一个管理和监督虚拟机的开源解决方案。-&gt;<a href=\"http://archipelproject.org/\" target=\"_blank\" rel=\"external\">项目主页</a>  -&gt;<a href=\"https://github.com/ArchipelProject/Archipel/wiki\" target=\"_blank\" rel=\"external\">GitHub地址</a> </p>\n<p><img src=\"https://camo.githubusercontent.com/18ac0e081edc75385b0ab4368455e2123961b6b6/68747470733a2f2f646c2e64726f70626f7875736572636f6e74656e742e636f6d2f752f323636333535322f417263686970656c2532302d25323050726f64756374696f6e2f57696b692f4172636869746563747572652f7468756d626e61696c732f61726368692e706e67\" alt=\"Architecture\"></p>\n<p> Archipel Agent　–即上图的Physical Hypervisor 安装在每台物理机上<br> Archipel Client　–即上图的Archipel GUI，安装在任意一台linux电脑上</p>\n<p>###一. Ejabberd XMPP 服务器端的配置安装</p>\n<p>Archipel</p>\n<p>XMPP服务器的域名就是本机的hostname, 我的hostname是　alecyrus.org , 这个可与通过命令” # hostname”得到，一般默认是ubuntu,　如果需要修改，可运行以下命令，别忘了之后在/etc/hosts 文件中，172.0.1.1 后在ubuntu后并列添加YourHostname，否则无法修改成功.</p>\n<pre><code># hostname YourHostname\n# echo YourHostname &gt; /etc/hostname\n</code></pre><p>1：安装ejabberd(至少15.04版本)</p>\n<pre><code># echo &quot;deb https://apt.jabber.at trusty ejabberd&quot; &gt; /etc/apt/sources.list.d/jabber.at.list\n# wget -qO- https://apt.jabber.at/gpg-key | apt-key add -\n# apt-get update\n# apt-get install ejabberd\n</code></pre><p>注：我是在ejabberd15.04版本下测试的，deb安装或者installer安装都行。两种方式安装后，打开关闭重启ejabberd服务的操作略有区别。具体查看<a href=\"docs.ejabberd.im/admin/guide/installation/\">ejabberd官方文档</a>如果安装后使用命令开启ejabberd服务时报错，诸如Failed RPC connection… File Operate Error… 说明ejabberd安装出错，自行查看log解决。</p>\n<p>2：安装必需的依赖包(ArchipelAgent也需要安装这些依赖包)</p>\n<pre><code># apt-get install -y git  build-essential qemu-kvm libvirt-bin libvirt-dev python-setuptools python-numpy python-imaging python-apscheduler python-sqlalchemy python-libvirt subversion python-dev\n</code></pre><p>３：配置Ejabberd<br>    老版本是ejabberd.cfg, 现在的版本都是yaml配置文件(ejabberd.yml)。<br>   如下：</p>\n<pre><code>###\n###             ejabberd configuration file\n###         Archipel Sample default condiguration\n\n###     =========================================\n###     DEBUGGING\n\n\nloglevel: 4\n\n###     =========================================\n###     SERVED HOSTNAMES\n\nhosts:\n    - &quot;alecyrus.org&quot;\n\n###     =========================================\n###     LISTENING PORTS\n\nlisten:\n-\n\n  port: 4560\n  module: ejabberd_xmlrpc\n  access_commands:\n        xmlrpcaccess:\n            all : []\n\n## ejabberd c2s\n-\n  port: 5222\n  module: ejabberd_c2s\n  max_stanza_size: 65536000\n  shaper: c2s_shaper\n  access: c2s\n\n## ejabbed s2s\n-\n  port: 5269\n  module: ejabberd_s2s_in\n  max_stanza_size: 65536000\n\n-\n  port: 5280\n  module: ejabberd_http\n  request_handlers:\n    &quot;/xmpp&quot;: ejabberd_http_ws\n  web_admin: true\n  http_bind: true\n\n###     ========================================\n###     S2S\ns2s_policy: s2s_access\ns2s_use_starttls: optional\n\n\n###     =========================================\n###     AUTHENTICATION\n\nauth_method: internal\n\n###     =========================================\n###     TRAFFIC SHAPERS\n\nshaper:\n  # in B/s\n  normal: 1000\n  fast: 50000000\n\n###     =========================================\n###     ACCESS CONTROL LISTS\n\nacl:\nadmin:\n    user:\n        - &quot;admin&quot;: &quot;alecyrus.org&quot;\nlocal:\n    user_regexp: &quot;&quot;\n\n\n###     =========================================\n###     ACCESS RULES\n\naccess:\nmax_user_sessions:\n    all: 10\nlocal:\n    local: allow\nc2s:\n    blocked: deny\n    all: allow\nc2s_shaper:        \n    admin: none\n    all: fast\ns2s_shaper:\n    all: fast\ns2s_access:\n    all: allow\nannounce:\n    admin: allow\nconfigure:\n    admin: allow\nmuc_admin:\n    admin: allow\nmuc_create:\n    local: allow\nmuc:\n    all: allow\npubsub_createnode:\n    all: allow\nregister:\n    all: allow\nxmlrpcaccess:\n    admin : allow\n\nregistration_timeout: infinity\n\n###     ========================================\n###     DEFAULT LANGUAGE\n\nlanguage: &quot;en&quot;\n\n###     ========================================\n###     MODULES\n\nmodules:\n  mod_admin_extra: []\n  mod_adhoc: []\n  mod_announce:\n    access: announce\n  mod_caps: []\n  mod_configure: []\n  mod_disco: []\n  mod_http_bind:\n    max_inactivity: 400 \n  mod_irc: []\n  mod_last: []\n  mod_muc:\n    access: muc\n    access_create: muc_create\n    access_persistent: muc_create\n    access_admin: muc_admin\n  mod_offline: []\n  mod_privacy: []\n  mod_private: []\n  mod_pubsub:\n    access_createnode: pubsub_createnode\n    ignore_pep_from_offline: true\n    last_item_cache: false\n    max_items_node: 1000\n    plugins:\n        - &quot;flat&quot;\n        - &quot;hometree&quot;\n        - &quot;pep&quot;\n  mod_register:\n    access: register\n  mod_roster: []\n  mod_shared_roster: []\n  mod_time: []\n  mod_vcard: []\n  mod_version: []\n</code></pre><p>然后重启ejabberd服务(DEB安装方式)，如果是installer安装，桌面上有俩快捷方式，若没有，进入ejabberd安装目录/bin/, 运行相关命令即可</p>\n<pre><code># /etc/init.d/ejabberd restart\n\n\n注：如果重启不成功，使用以下命令来查看启动服务过程中是哪里出问题，一般都是配置文档\n出错，语法，模块错误什么的。\n\n# ejabberdctl live\n</code></pre><p>4：ejabberd xmpp服务器admin账户的注册(DEB安装方式，若是install方式，在安装ejabberd时就创建好了)</p>\n<pre><code># ejabberdctl register admin alecyrus.org YourPassWd\n</code></pre><p>####二. Archipel Agent的配置安装<br>  Archipel Agent是需要安装在每台物理机上,物理机上的Virtual Machine Monitor 可以是KVM、Xen、VMware… ,以后如果需要把某台物理机上的全部KVM虚拟机添加到Archipel,那就需要在这台物理机上安装Archipel Agent.</p>\n<p>前提：能够正常创建虚拟机，qumu，kvm这些的安装好。</p>\n<p>１：下载Archipel以及安装</p>\n<pre><code># git clone https://github.com/ArchipelProject/Archipel.git\n# cd Archipel\n# ./pull.sh\n# easy_install apscheduler sqlalchemy numpy\n# cd ArchipelAgent\n# ./buildAgent -d\n# archipel-initinstall\n</code></pre><p>注：通常在archipel-initinstall加上 -x FQDN(# archipel-initinstall -x   alecyrus.org), 意思就是指定这台Physical Hypervisor将要连接的XMPP服务  器  的地址，如果你XMPP服务器和Physical Hypervisor安装在同一台机器上，比如现在，那么Physical Hypervisor 中Archipel的配置没问题，同一台机器，Physical Hypervisor 和XMPP服务器当然能够互相ping通。<br>  但是如果以后XMPP服务器配置好了，你想把其他的Physical Hypervisor 添加到XMPP服务器上让ArchipelClient一并管理，如果还是如此配置，那么这台Physical Hypervisor 就无法识别alecyrus.org, 所以在其他机器安装ArchipelAgent，别忘了在hosts文件中添加alecyrus.org 和XMPP服务器ip的映射。同时，保证XMPP服务器与Physical Hypervisor 能相互ping通。</p>\n<p>２：将这台Physical Hypervisor 的ArchipelAgent初始化到XMPP服务器，使用你的XMPP服务器的管理员账号。</p>\n<pre><code># archipel-tagnode -j admin@alecyrus.org -p  YourPassWD --create\n# archipel-rolesnode -j admin@alecyrus.org -p YourPassWD --create\n# archipel-adminaccounts -j admin@alecyrus.org -p YourPassWD --create\n</code></pre><p>3：配置Archipel Agent</p>\n<p>编辑/etc/archipel.conf, 添加以下内容</p>\n<pre><code>[MODULES]\n\naction_scheduler            = True\ncentraldb                   = True\ngeolocalization             = True\nhypervisor_health           = True\nhypervisor_network          = True\nhypervisor_vmcasts          = True\niphone_notification         = False\noomkiller                   = True\nsnapshoting                 = True\nstorage                     = True\nvirtualmachine_appliance    = True\nvnc                         = True\nxmppserver                  = True\nvmparking                   = True  # needs centraldb to be     activated\n\n[CENTRALAGENT]\n# centralagent can be :\n#  - auto (default) : will be central agent if there is none already started\n#  - force : will be central agent (be careful to configure only one of your hypervisors this way)\ncentralagent               = auto\n\n[VNC]\nvnc_certificate_file                        = None\nvnc_only_ssl                                = False\nvnc_enable_websocket_debug                  = True\n</code></pre><p>注：最后将machine_ip由auto改成这台hypervisor的ip地址，这样方便archipel查看ip地址。</p>\n<p>4:重启Archipel</p>\n<pre><code># /etc/init.d/archipel restart\n</code></pre><p>####三. Archipel Client安装　<br>  Archipel Client就是一个web应用，通过官方发布的The nightlies版本可以很方便的安装的，但经过测试(Ubuntu 14.04LTS)，项目作者把centralAgent也加入admin list后，centralAgent就无法正常安装了，bu<br>以下命令在之前clone命令的同级目录下进行，即开始这条命令时，ls命令可以可以看到之前的Archipel文件夹。</p>\n<pre><code># wget http://nightlies.archipelproject.org/latest-archipel-client.tar.gz\n# tar -xzf latest-archipel-client.tar.gz\n</code></pre><p>####四. 最后的工作</p>\n<p>进入Archipel目录开启HTTP服务</p>\n<p>  １：开启8000端口</p>\n<pre><code># python -m SimpleHTTPServer\n\n注:务必进入Archipel目录运行这个命令\n</code></pre><p>２：<br>    打开网址：localhost:8000<br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-0d5a0c620f259122.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>登陆信息如上<br>然后添加安装了Archipel Agent的Physical Hypervisor　的JID…</p>\n<p>这个JID的格式可以在archipel.conf 中看到。。如下：</p>\n<p>我这里是alecyrus@%(xmpp_server)s，，也就是说JID为：<br>alecyrus@alecyrus.org<br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-fa23335e07986c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-791ee902e581d2d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2016-01-18 02:04:30屏幕截图.png\"></p>\n<p>添加完成后，就可以在这里看到你的物理机的虚拟机管理程序了，不过它变了样子</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-aa4593d21dae1b1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"2016-01-18 02:14:08屏幕截图.png\"></p>\n<p>一个Physical Hypervisor就是你的一个联系人，这个联系人下面可以有很多的虚拟机，你也可以把虚拟机添加联系人中。</p>\n<p>Done！</p>\n"},{"title":"扩展Compute节点","date":"2016-09-20T12:03:07.000Z","_content":"\n## 准备工作\n\n### 计算节点设置apt-cacher代理\n>`# echo 'Acquire::http::Proxy \"http://{proxy_server_ip}:{port}\";' > /etc/apt/apt.conf`\n\n### 若之前执行过apt-get update命令， 则运行一下命令\n>`# rm /var/lib/apt/lists/partial/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_\nPackages\n`\n\n### 修改软件源为阿里云\n>`# vim /etc/apt/source.list`\n>`:%s/cn.archive.ubuntu/mirrors.aliyun/g`\n>`# apt-get update`\n\n### 安装KVM\n>`# apt-get install qemu-kvm qemu-system libvirt-bin  bridge-utils`\n\n### 配置语言\n>`# apt-get -y install language-pack-zh-hans`\n### 修改/etc/hosts文件\n>`# scp {username}@{ip}:/etc/hosts /etc/hosts`\n>此时用`ping`验证一下当前节点与其他节点的互联性\n\n### 修改主机名\n>我们以节点ip的最后一位作为节点序号\n>>`# hostname compute$n`\n>`# echo \"compute$n\"  > /etc/hostname`\n\n>将$n替换为对应的节点序号\n\n### 重新登录使主机名更改生效\n>这里exit后再次ssh连接即可\n\n>![](http://upload-images.jianshu.io/upload_images/1113810-1319a3036e9167db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 配置OpenStack Provider Network Interface\n>`# vim /etc/network/interfaces`\n> 在末尾添加以下内容:\n\n>---\n>>`# The provider network interface\n>auto em3\n>iface  em3 inet manual\n>up ip link set dev $IFACE up\n>down ip link set dev $IFACE down`\n\n>---\n> 启动Provider Interface\n> `# ifup em3`\n>如果em3启动失败，则通过ip link检查是否存在em3网卡\n\n## 开始部署\n\n### 配置NTP服务\n>`# apt-get install chrony -y`\n> 编辑 /etc/chrony/chrony.conf， 修改相关内容为\n>> `server controller iburst`\n![](http://upload-images.jianshu.io/upload_images/1113810-cf638a891f14fe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>验证ntp服务\n>>`# service chrony restart`\n>>`# chronyc sources`\n>> ![](http://upload-images.jianshu.io/upload_images/1113810-440082195c472e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 配置OpenStack 软件源以及相关依赖\n> 设置软件源\n>>`# apt-get install software-properties-common && add-apt-repository cloud-archive:mitaka`\n\n>更新本地仓库以及安装OpenStackClient\n>>`# apt-get update && apt-get dist-upgrade &&  apt-get install python-openstackclient`\n\n>---\n> 如果出现网络错误，重新执行相关命令\n\n### 配置服务\n####安装软件包\n>`# apt-get install -y nova-compute`\n`# apt-get install -y neutron-linuxbridge-agent`\n>`获取启动脚本文件`:`# scp {username}@compute1:/home/hit/compute_service ./`\n\n\n#### 配置Nova\n\n\n\n>备份\n>>`# cp /etc/nova/nova.conf /etc/nova/nova.conf.bak`\n\n>获取配置文件\n>>`# scp root@192.168.100.1:/etc/nova/nova.conf  /etc/nova/nova.conf`\n>修改配置文件，修改ip为本节点ip\n>>`[DEFAULT]\n...\nmy_ip = {ip}\n`\n>![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1113810-d3c90aef01632d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 配置Neutron\n>备份以下两个文件\n>>`#  cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak`\n`# /etc/neutron/plugins/ml2/linuxbridge_agent.ini /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak`\n\n\n>获取配置文件\n>>`# scp root@192.168.100.1:/etc/neutron/neutron.conf /etc/neutron/neutron.conf`\n`# scp root@192.168.100.1:/etc/neutron/plugins/ml2/linuxbridge_agent.ini  /etc/neutron/plugins/ml2/linuxbridge_agent.ini`\n\n\n\n>修改配置文件linuxbridge_agent.ini,修改provider Interface为之前配置OpenStack Provider Network Interface，修改ip为本节点ip:`192.168.100.X`\n\n>>`[DEFAULT]\n>...\n>physical_interface_mappings = provider:em3`\n\n>---\n>>`[vxlan]\n...\nenable_vxlan = True\nlocal_ip = {ip}\nl2_population = True`\n\n>---\n>![](http://upload-images.jianshu.io/upload_images/1113810-14ae21842a7324ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>![](http://upload-images.jianshu.io/upload_images/1113810-05c83c0cabe0ce37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>重启计算节点服务\n>`#./compute_service`\n\n#### 验证\n> 在控制节点运行，查看新添加的节点是否在线，当前新添加的为`compute2`\n>>`#. admin-openrc`\n>>`# nova service-list`\n>>`# neutron agent-list`\n\n\n>![](http://upload-images.jianshu.io/upload_images/1113810-19012f6fe28ec51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>![](http://upload-images.jianshu.io/upload_images/1113810-0d8cc4c55db44884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","source":"_posts/扩展Compute节点.md","raw":"---\ntitle: 扩展Compute节点\ndate: 2016-09-20 05:03:07\ntags:\n - OpenStack\n---\n\n## 准备工作\n\n### 计算节点设置apt-cacher代理\n>`# echo 'Acquire::http::Proxy \"http://{proxy_server_ip}:{port}\";' > /etc/apt/apt.conf`\n\n### 若之前执行过apt-get update命令， 则运行一下命令\n>`# rm /var/lib/apt/lists/partial/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_\nPackages\n`\n\n### 修改软件源为阿里云\n>`# vim /etc/apt/source.list`\n>`:%s/cn.archive.ubuntu/mirrors.aliyun/g`\n>`# apt-get update`\n\n### 安装KVM\n>`# apt-get install qemu-kvm qemu-system libvirt-bin  bridge-utils`\n\n### 配置语言\n>`# apt-get -y install language-pack-zh-hans`\n### 修改/etc/hosts文件\n>`# scp {username}@{ip}:/etc/hosts /etc/hosts`\n>此时用`ping`验证一下当前节点与其他节点的互联性\n\n### 修改主机名\n>我们以节点ip的最后一位作为节点序号\n>>`# hostname compute$n`\n>`# echo \"compute$n\"  > /etc/hostname`\n\n>将$n替换为对应的节点序号\n\n### 重新登录使主机名更改生效\n>这里exit后再次ssh连接即可\n\n>![](http://upload-images.jianshu.io/upload_images/1113810-1319a3036e9167db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n### 配置OpenStack Provider Network Interface\n>`# vim /etc/network/interfaces`\n> 在末尾添加以下内容:\n\n>---\n>>`# The provider network interface\n>auto em3\n>iface  em3 inet manual\n>up ip link set dev $IFACE up\n>down ip link set dev $IFACE down`\n\n>---\n> 启动Provider Interface\n> `# ifup em3`\n>如果em3启动失败，则通过ip link检查是否存在em3网卡\n\n## 开始部署\n\n### 配置NTP服务\n>`# apt-get install chrony -y`\n> 编辑 /etc/chrony/chrony.conf， 修改相关内容为\n>> `server controller iburst`\n![](http://upload-images.jianshu.io/upload_images/1113810-cf638a891f14fe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>验证ntp服务\n>>`# service chrony restart`\n>>`# chronyc sources`\n>> ![](http://upload-images.jianshu.io/upload_images/1113810-440082195c472e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 配置OpenStack 软件源以及相关依赖\n> 设置软件源\n>>`# apt-get install software-properties-common && add-apt-repository cloud-archive:mitaka`\n\n>更新本地仓库以及安装OpenStackClient\n>>`# apt-get update && apt-get dist-upgrade &&  apt-get install python-openstackclient`\n\n>---\n> 如果出现网络错误，重新执行相关命令\n\n### 配置服务\n####安装软件包\n>`# apt-get install -y nova-compute`\n`# apt-get install -y neutron-linuxbridge-agent`\n>`获取启动脚本文件`:`# scp {username}@compute1:/home/hit/compute_service ./`\n\n\n#### 配置Nova\n\n\n\n>备份\n>>`# cp /etc/nova/nova.conf /etc/nova/nova.conf.bak`\n\n>获取配置文件\n>>`# scp root@192.168.100.1:/etc/nova/nova.conf  /etc/nova/nova.conf`\n>修改配置文件，修改ip为本节点ip\n>>`[DEFAULT]\n...\nmy_ip = {ip}\n`\n>![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1113810-d3c90aef01632d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n#### 配置Neutron\n>备份以下两个文件\n>>`#  cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak`\n`# /etc/neutron/plugins/ml2/linuxbridge_agent.ini /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak`\n\n\n>获取配置文件\n>>`# scp root@192.168.100.1:/etc/neutron/neutron.conf /etc/neutron/neutron.conf`\n`# scp root@192.168.100.1:/etc/neutron/plugins/ml2/linuxbridge_agent.ini  /etc/neutron/plugins/ml2/linuxbridge_agent.ini`\n\n\n\n>修改配置文件linuxbridge_agent.ini,修改provider Interface为之前配置OpenStack Provider Network Interface，修改ip为本节点ip:`192.168.100.X`\n\n>>`[DEFAULT]\n>...\n>physical_interface_mappings = provider:em3`\n\n>---\n>>`[vxlan]\n...\nenable_vxlan = True\nlocal_ip = {ip}\nl2_population = True`\n\n>---\n>![](http://upload-images.jianshu.io/upload_images/1113810-14ae21842a7324ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>![](http://upload-images.jianshu.io/upload_images/1113810-05c83c0cabe0ce37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n>重启计算节点服务\n>`#./compute_service`\n\n#### 验证\n> 在控制节点运行，查看新添加的节点是否在线，当前新添加的为`compute2`\n>>`#. admin-openrc`\n>>`# nova service-list`\n>>`# neutron agent-list`\n\n\n>![](http://upload-images.jianshu.io/upload_images/1113810-19012f6fe28ec51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n>![](http://upload-images.jianshu.io/upload_images/1113810-0d8cc4c55db44884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","slug":"扩展Compute节点","published":1,"updated":"2017-05-15T12:06:55.914Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r14000dmqjxx9ildlkk","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"计算节点设置apt-cacher代理\"><a href=\"#计算节点设置apt-cacher代理\" class=\"headerlink\" title=\"计算节点设置apt-cacher代理\"></a>计算节点设置apt-cacher代理</h3><blockquote>\n<p><code># echo &#39;Acquire::http::Proxy &quot;http://{proxy_server_ip}:{port}&quot;;&#39; &gt; /etc/apt/apt.conf</code></p>\n</blockquote>\n<h3 id=\"若之前执行过apt-get-update命令，-则运行一下命令\"><a href=\"#若之前执行过apt-get-update命令，-则运行一下命令\" class=\"headerlink\" title=\"若之前执行过apt-get update命令， 则运行一下命令\"></a>若之前执行过apt-get update命令， 则运行一下命令</h3><blockquote>\n<p><code># rm /var/lib/apt/lists/partial/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_\nPackages</code></p>\n</blockquote>\n<h3 id=\"修改软件源为阿里云\"><a href=\"#修改软件源为阿里云\" class=\"headerlink\" title=\"修改软件源为阿里云\"></a>修改软件源为阿里云</h3><blockquote>\n<p><code># vim /etc/apt/source.list</code><br><code>:%s/cn.archive.ubuntu/mirrors.aliyun/g</code><br><code># apt-get update</code></p>\n</blockquote>\n<h3 id=\"安装KVM\"><a href=\"#安装KVM\" class=\"headerlink\" title=\"安装KVM\"></a>安装KVM</h3><blockquote>\n<p><code># apt-get install qemu-kvm qemu-system libvirt-bin  bridge-utils</code></p>\n</blockquote>\n<h3 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h3><blockquote>\n<p><code># apt-get -y install language-pack-zh-hans</code></p>\n<h3 id=\"修改-etc-hosts文件\"><a href=\"#修改-etc-hosts文件\" class=\"headerlink\" title=\"修改/etc/hosts文件\"></a>修改/etc/hosts文件</h3><p><code># scp {username}@{ip}:/etc/hosts /etc/hosts</code><br>此时用<code>ping</code>验证一下当前节点与其他节点的互联性</p>\n</blockquote>\n<h3 id=\"修改主机名\"><a href=\"#修改主机名\" class=\"headerlink\" title=\"修改主机名\"></a>修改主机名</h3><blockquote>\n<p>我们以节点ip的最后一位作为节点序号</p>\n<blockquote>\n<p><code># hostname compute$n</code><br><code># echo &quot;compute$n&quot;  &gt; /etc/hostname</code></p>\n</blockquote>\n<p>将$n替换为对应的节点序号</p>\n</blockquote>\n<h3 id=\"重新登录使主机名更改生效\"><a href=\"#重新登录使主机名更改生效\" class=\"headerlink\" title=\"重新登录使主机名更改生效\"></a>重新登录使主机名更改生效</h3><blockquote>\n<p>这里exit后再次ssh连接即可</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-1319a3036e9167db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"配置OpenStack-Provider-Network-Interface\"><a href=\"#配置OpenStack-Provider-Network-Interface\" class=\"headerlink\" title=\"配置OpenStack Provider Network Interface\"></a>配置OpenStack Provider Network Interface</h3><blockquote>\n<p><code># vim /etc/network/interfaces</code><br>在末尾添加以下内容:</p>\n<hr>\n<blockquote>\n<p><code># The provider network interface\nauto em3\niface  em3 inet manual\nup ip link set dev $IFACE up\ndown ip link set dev $IFACE down</code></p>\n</blockquote>\n<hr>\n<p>启动Provider Interface<br><code># ifup em3</code><br>如果em3启动失败，则通过ip link检查是否存在em3网卡</p>\n</blockquote>\n<h2 id=\"开始部署\"><a href=\"#开始部署\" class=\"headerlink\" title=\"开始部署\"></a>开始部署</h2><h3 id=\"配置NTP服务\"><a href=\"#配置NTP服务\" class=\"headerlink\" title=\"配置NTP服务\"></a>配置NTP服务</h3><blockquote>\n<p><code># apt-get install chrony -y</code><br>编辑 /etc/chrony/chrony.conf， 修改相关内容为</p>\n<blockquote>\n<p><code>server controller iburst</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-cf638a891f14fe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>验证ntp服务</p>\n<blockquote>\n<p><code># service chrony restart</code><br><code># chronyc sources</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-440082195c472e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n</blockquote>\n<h3 id=\"配置OpenStack-软件源以及相关依赖\"><a href=\"#配置OpenStack-软件源以及相关依赖\" class=\"headerlink\" title=\"配置OpenStack 软件源以及相关依赖\"></a>配置OpenStack 软件源以及相关依赖</h3><blockquote>\n<p>设置软件源</p>\n<blockquote>\n<p><code># apt-get install software-properties-common &amp;&amp; add-apt-repository cloud-archive:mitaka</code></p>\n</blockquote>\n<p>更新本地仓库以及安装OpenStackClient</p>\n<blockquote>\n<p><code># apt-get update &amp;&amp; apt-get dist-upgrade &amp;&amp;  apt-get install python-openstackclient</code></p>\n</blockquote>\n<hr>\n<p>如果出现网络错误，重新执行相关命令</p>\n</blockquote>\n<h3 id=\"配置服务\"><a href=\"#配置服务\" class=\"headerlink\" title=\"配置服务\"></a>配置服务</h3><p>####安装软件包</p>\n<blockquote>\n<p><code># apt-get install -y nova-compute</code><br><code># apt-get install -y neutron-linuxbridge-agent</code><br><code>获取启动脚本文件</code>:<code># scp {username}@compute1:/home/hit/compute_service ./</code></p>\n</blockquote>\n<h4 id=\"配置Nova\"><a href=\"#配置Nova\" class=\"headerlink\" title=\"配置Nova\"></a>配置Nova</h4><blockquote>\n<p>备份</p>\n<blockquote>\n<p><code># cp /etc/nova/nova.conf /etc/nova/nova.conf.bak</code></p>\n</blockquote>\n<p>获取配置文件</p>\n<blockquote>\n<p><code># scp root@192.168.100.1:/etc/nova/nova.conf  /etc/nova/nova.conf</code><br>修改配置文件，修改ip为本节点ip<br><code>[DEFAULT]\n...\nmy_ip = {ip}</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-d3c90aef01632d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n</blockquote>\n</blockquote>\n<h4 id=\"配置Neutron\"><a href=\"#配置Neutron\" class=\"headerlink\" title=\"配置Neutron\"></a>配置Neutron</h4><blockquote>\n<p>备份以下两个文件</p>\n<blockquote>\n<p><code>#  cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak</code><br><code># /etc/neutron/plugins/ml2/linuxbridge_agent.ini /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak</code></p>\n</blockquote>\n<p>获取配置文件</p>\n<blockquote>\n<p><code># scp root@192.168.100.1:/etc/neutron/neutron.conf /etc/neutron/neutron.conf</code><br><code># scp root@192.168.100.1:/etc/neutron/plugins/ml2/linuxbridge_agent.ini  /etc/neutron/plugins/ml2/linuxbridge_agent.ini</code></p>\n</blockquote>\n<p>修改配置文件linuxbridge_agent.ini,修改provider Interface为之前配置OpenStack Provider Network Interface，修改ip为本节点ip:<code>192.168.100.X</code></p>\n<blockquote>\n<p><code>[DEFAULT]\n...\nphysical_interface_mappings = provider:em3</code></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><code>[vxlan]\n...\nenable_vxlan = True\nlocal_ip = {ip}\nl2_population = True</code></p>\n</blockquote>\n<hr>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-14ae21842a7324ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-05c83c0cabe0ce37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>重启计算节点服务<br><code>#./compute_service</code></p>\n</blockquote>\n<h4 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h4><blockquote>\n<p>在控制节点运行，查看新添加的节点是否在线，当前新添加的为<code>compute2</code></p>\n<blockquote>\n<p><code>#. admin-openrc</code><br><code># nova service-list</code><br><code># neutron agent-list</code></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-19012f6fe28ec51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-0d8cc4c55db44884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"计算节点设置apt-cacher代理\"><a href=\"#计算节点设置apt-cacher代理\" class=\"headerlink\" title=\"计算节点设置apt-cacher代理\"></a>计算节点设置apt-cacher代理</h3><blockquote>\n<p><code># echo &#39;Acquire::http::Proxy &quot;http://{proxy_server_ip}:{port}&quot;;&#39; &gt; /etc/apt/apt.conf</code></p>\n</blockquote>\n<h3 id=\"若之前执行过apt-get-update命令，-则运行一下命令\"><a href=\"#若之前执行过apt-get-update命令，-则运行一下命令\" class=\"headerlink\" title=\"若之前执行过apt-get update命令， 则运行一下命令\"></a>若之前执行过apt-get update命令， 则运行一下命令</h3><blockquote>\n<p><code># rm /var/lib/apt/lists/partial/security.ubuntu.com_ubuntu_dists_trusty-security_main_binary-i386_\nPackages</code></p>\n</blockquote>\n<h3 id=\"修改软件源为阿里云\"><a href=\"#修改软件源为阿里云\" class=\"headerlink\" title=\"修改软件源为阿里云\"></a>修改软件源为阿里云</h3><blockquote>\n<p><code># vim /etc/apt/source.list</code><br><code>:%s/cn.archive.ubuntu/mirrors.aliyun/g</code><br><code># apt-get update</code></p>\n</blockquote>\n<h3 id=\"安装KVM\"><a href=\"#安装KVM\" class=\"headerlink\" title=\"安装KVM\"></a>安装KVM</h3><blockquote>\n<p><code># apt-get install qemu-kvm qemu-system libvirt-bin  bridge-utils</code></p>\n</blockquote>\n<h3 id=\"配置语言\"><a href=\"#配置语言\" class=\"headerlink\" title=\"配置语言\"></a>配置语言</h3><blockquote>\n<p><code># apt-get -y install language-pack-zh-hans</code></p>\n<h3 id=\"修改-etc-hosts文件\"><a href=\"#修改-etc-hosts文件\" class=\"headerlink\" title=\"修改/etc/hosts文件\"></a>修改/etc/hosts文件</h3><p><code># scp {username}@{ip}:/etc/hosts /etc/hosts</code><br>此时用<code>ping</code>验证一下当前节点与其他节点的互联性</p>\n</blockquote>\n<h3 id=\"修改主机名\"><a href=\"#修改主机名\" class=\"headerlink\" title=\"修改主机名\"></a>修改主机名</h3><blockquote>\n<p>我们以节点ip的最后一位作为节点序号</p>\n<blockquote>\n<p><code># hostname compute$n</code><br><code># echo &quot;compute$n&quot;  &gt; /etc/hostname</code></p>\n</blockquote>\n<p>将$n替换为对应的节点序号</p>\n</blockquote>\n<h3 id=\"重新登录使主机名更改生效\"><a href=\"#重新登录使主机名更改生效\" class=\"headerlink\" title=\"重新登录使主机名更改生效\"></a>重新登录使主机名更改生效</h3><blockquote>\n<p>这里exit后再次ssh连接即可</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-1319a3036e9167db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<h3 id=\"配置OpenStack-Provider-Network-Interface\"><a href=\"#配置OpenStack-Provider-Network-Interface\" class=\"headerlink\" title=\"配置OpenStack Provider Network Interface\"></a>配置OpenStack Provider Network Interface</h3><blockquote>\n<p><code># vim /etc/network/interfaces</code><br>在末尾添加以下内容:</p>\n<hr>\n<blockquote>\n<p><code># The provider network interface\nauto em3\niface  em3 inet manual\nup ip link set dev $IFACE up\ndown ip link set dev $IFACE down</code></p>\n</blockquote>\n<hr>\n<p>启动Provider Interface<br><code># ifup em3</code><br>如果em3启动失败，则通过ip link检查是否存在em3网卡</p>\n</blockquote>\n<h2 id=\"开始部署\"><a href=\"#开始部署\" class=\"headerlink\" title=\"开始部署\"></a>开始部署</h2><h3 id=\"配置NTP服务\"><a href=\"#配置NTP服务\" class=\"headerlink\" title=\"配置NTP服务\"></a>配置NTP服务</h3><blockquote>\n<p><code># apt-get install chrony -y</code><br>编辑 /etc/chrony/chrony.conf， 修改相关内容为</p>\n<blockquote>\n<p><code>server controller iburst</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-cf638a891f14fe98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n<p>验证ntp服务</p>\n<blockquote>\n<p><code># service chrony restart</code><br><code># chronyc sources</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-440082195c472e51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n</blockquote>\n<h3 id=\"配置OpenStack-软件源以及相关依赖\"><a href=\"#配置OpenStack-软件源以及相关依赖\" class=\"headerlink\" title=\"配置OpenStack 软件源以及相关依赖\"></a>配置OpenStack 软件源以及相关依赖</h3><blockquote>\n<p>设置软件源</p>\n<blockquote>\n<p><code># apt-get install software-properties-common &amp;&amp; add-apt-repository cloud-archive:mitaka</code></p>\n</blockquote>\n<p>更新本地仓库以及安装OpenStackClient</p>\n<blockquote>\n<p><code># apt-get update &amp;&amp; apt-get dist-upgrade &amp;&amp;  apt-get install python-openstackclient</code></p>\n</blockquote>\n<hr>\n<p>如果出现网络错误，重新执行相关命令</p>\n</blockquote>\n<h3 id=\"配置服务\"><a href=\"#配置服务\" class=\"headerlink\" title=\"配置服务\"></a>配置服务</h3><p>####安装软件包</p>\n<blockquote>\n<p><code># apt-get install -y nova-compute</code><br><code># apt-get install -y neutron-linuxbridge-agent</code><br><code>获取启动脚本文件</code>:<code># scp {username}@compute1:/home/hit/compute_service ./</code></p>\n</blockquote>\n<h4 id=\"配置Nova\"><a href=\"#配置Nova\" class=\"headerlink\" title=\"配置Nova\"></a>配置Nova</h4><blockquote>\n<p>备份</p>\n<blockquote>\n<p><code># cp /etc/nova/nova.conf /etc/nova/nova.conf.bak</code></p>\n</blockquote>\n<p>获取配置文件</p>\n<blockquote>\n<p><code># scp root@192.168.100.1:/etc/nova/nova.conf  /etc/nova/nova.conf</code><br>修改配置文件，修改ip为本节点ip<br><code>[DEFAULT]\n...\nmy_ip = {ip}</code><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-d3c90aef01632d14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Paste_Image.png\"></p>\n</blockquote>\n</blockquote>\n<h4 id=\"配置Neutron\"><a href=\"#配置Neutron\" class=\"headerlink\" title=\"配置Neutron\"></a>配置Neutron</h4><blockquote>\n<p>备份以下两个文件</p>\n<blockquote>\n<p><code>#  cp /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak</code><br><code># /etc/neutron/plugins/ml2/linuxbridge_agent.ini /etc/neutron/plugins/ml2/linuxbridge_agent.ini.bak</code></p>\n</blockquote>\n<p>获取配置文件</p>\n<blockquote>\n<p><code># scp root@192.168.100.1:/etc/neutron/neutron.conf /etc/neutron/neutron.conf</code><br><code># scp root@192.168.100.1:/etc/neutron/plugins/ml2/linuxbridge_agent.ini  /etc/neutron/plugins/ml2/linuxbridge_agent.ini</code></p>\n</blockquote>\n<p>修改配置文件linuxbridge_agent.ini,修改provider Interface为之前配置OpenStack Provider Network Interface，修改ip为本节点ip:<code>192.168.100.X</code></p>\n<blockquote>\n<p><code>[DEFAULT]\n...\nphysical_interface_mappings = provider:em3</code></p>\n</blockquote>\n<hr>\n<blockquote>\n<p><code>[vxlan]\n...\nenable_vxlan = True\nlocal_ip = {ip}\nl2_population = True</code></p>\n</blockquote>\n<hr>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-14ae21842a7324ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-05c83c0cabe0ce37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>重启计算节点服务<br><code>#./compute_service</code></p>\n</blockquote>\n<h4 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h4><blockquote>\n<p>在控制节点运行，查看新添加的节点是否在线，当前新添加的为<code>compute2</code></p>\n<blockquote>\n<p><code>#. admin-openrc</code><br><code># nova service-list</code><br><code># neutron agent-list</code></p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/1113810-19012f6fe28ec51a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"><br><img src=\"http://upload-images.jianshu.io/upload_images/1113810-0d8cc4c55db44884.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n</blockquote>\n"},{"title":"父进程如何捕获子进程的异常？","date":"2016-08-15T12:01:59.000Z","_content":"\n### 摘要\n在使用Python开发某些高并发WEB应用后台时，为了提高处理能力，通常会采用多进程或者多线程的方式，但这同时也给异常处理带了一些麻烦。 \n\n----------------\n### 背景\n线程是一个轻型实体，只有由很少的支持其独立运行的资源。 对于Python，线程拥有自己独立的栈， 当线程运行出错，线程会直接结束运行，当需要进行错误处理时，一般都会在线程中进行处理，但是如果只能由主进程来处理异常，那么线程要怎么才能将异常通知给主进程呢？\n对于进程，子进程的产生的异常如何让父进程去处理？\n\n----------------\n### Multiprocessing Package\n`Multiprocessing`是Python的一个多进程库，其实现的API类似`threading`. 其子模块`dummy`实现了与`Multiprocessing.process`相同的API，唯一的区别在于，`dummy`其实只是对`threading`做了一层封装而已. 这给不知道是CPU密集型或者是IO密集型的项目提供了便利，你可以自由地在多进程与多线程之间进行切换而只需更改一行代码。\n\n-------------------\n### 调用error_callback函数\n在python3中， `Multiprocessing`对与`apply_async()`进行了改进，增加了一个默认参数`error_callback=None`，在这里你可以指定相应的错误处理函数，它将在子进程或者子线程运行出现异常是被调用. 与之对应的是`callback=None`参数(Python2也支持)，它将在子进程或者子线程顺利运行之后被调用.\n其原理，在于子线程或者子进程的一个`_success`属性， 其指出了运行状态.\n```python\n    def get(self, timeout=None):\n        self.wait(timeout)\n        if not self.ready():\n            raise TimeoutError\n        if self._success:\n            return self._value\n        else:\n            raise self._value\n\n    def _set(self, i, obj):\n        self._success, self._value = obj\n        if self._callback and self._success:\n            self._callback(self._value)\n        if self._error_callback and not self._success:\n            self._error_callback(self._value)\n        self._event.set()\n        del self._cache[self._job]\n``` \n需要注意的是，`raise self._value`语句抛出的是一个`Exception.AttributeError`,  可以看出只会抛出两种错误，一种是超时错误，一种是`AttributeError`. 而我们能利用的就是`AttributeError`, 在线程或者进程执行过程种出现错误， 我们只需要将合适的错误信息使用`格式化字符串`通过AttributeError传递出去，在`error_callback`去获取这个错误信息，在进行进一步的处理即可， 如果你只需要告知主进程出错了，那么只需要`raise AttributeError`即可. \n\n---------------------\n### 进程间数据共享\n不推荐`pipe`和`queue`，而它们都有可能堵塞进程，所以最好采用其他方式，这里介绍两种，共享内存变量，以及服务进程Manager. 你可以通过使用这两种方式在主进程中检测子线程或者子进程的状态. 至于访问速度，前者与和直接访问内存速度相差无几， 后者速度要低两个数量级\n#### 共享内存变量 Shared  Ctypes Objects\nmulti提供了两种类型，`Multiprocessing.Value`以及`MultiProcessing.Array`, 这两种结果内部实现了Lock，默认是开启的, 因此这时，它们是`process-safe`的. 共享内存变量在父进程中被创建，然后在创建子进程的时候传进去即可. \n\n官方文档示例代码：\n```python\nfrom multiprocessing import Process, Lock\nfrom multiprocessing.sharedctypes import Value, Array\nfrom ctypes import Structure, c_double\n\nclass Point(Structure):\n    _fields_ = [('x', c_double), ('y', c_double)]\n\ndef modify(n, x, s, A):\n    n.value **= 2\n    x.value **= 2\n    s.value = s.value.upper()\n    for a in A:\n        a.x **= 2\n        a.y **= 2\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    n = Value('i', 7)\n    x = Value(c_double, 1.0/3.0, lock=False)\n    s = Array('c', b'hello world', lock=lock)\n    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n\n    p = Process(target=modify, args=(n, x, s, A))\n    p.start()\n    p.join()\n\n    print(\"Ounput:\")\n    print(n.value)\n    print(x.value)\n    print(s.value)\n    print([(a.x, a.y) for a in A])\n```\n> Output:\n> 49\n> 0.1111111111111111\n> HELLO WORLD\n> [(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]\n\n#### 服务进程 Manager\n如果你需要支持更多类型数据的共享呢？ Sever Process Manager 可以完成， 它支持很多数据类型，包括`list`, `dict`, `Namespace`, `Lock`, `RLock`, `Semaphore`, `BoundedSemaphore`, `Condition`, `Event`, `Queue`, `Value`和`Array`. 作为一个独立的服务进程存在，意味着可以远程共享数据，内部实现类似与RPC服务器，每个需要进行读写共享数据的进程，都需要通过proxies来访问服务进程进行操作. 一个Manager对象就控制一个用于管理共享数据的服务进程。由于访问是在网络之上进行的， 因此速度方面没有共享内存快.\nManager的[具体使用方法][1]\n\n--------------------\n### 检查线程退出状态\n由于线程出现异常退出和正常退出时的`exitcode`时不一样的，而线程结束运行后，内存又不会立即被回收，基于此，我们可以通过检查`exitcode`的方式来捕获线程中出现的错误，这种方法来自[PengMeng's Blog][2], 一般地，Python中进程的属性, 或许可以达到和`exitcode`相同的效果. 这里不再深入讨论.\n\n[1]:https://docs.python.org/dev/library/multiprocessing.html#shared-ctypes-objects\n[2]:http://www.jianshu.com/p/e672152d6753\n","source":"_posts/父进程如何捕获子进程的异常？.md","raw":"---\ntitle: 父进程如何捕获子进程的异常？\ndate: 2016-08-15 05:01:59\ntags:\n - Python\n---\n\n### 摘要\n在使用Python开发某些高并发WEB应用后台时，为了提高处理能力，通常会采用多进程或者多线程的方式，但这同时也给异常处理带了一些麻烦。 \n\n----------------\n### 背景\n线程是一个轻型实体，只有由很少的支持其独立运行的资源。 对于Python，线程拥有自己独立的栈， 当线程运行出错，线程会直接结束运行，当需要进行错误处理时，一般都会在线程中进行处理，但是如果只能由主进程来处理异常，那么线程要怎么才能将异常通知给主进程呢？\n对于进程，子进程的产生的异常如何让父进程去处理？\n\n----------------\n### Multiprocessing Package\n`Multiprocessing`是Python的一个多进程库，其实现的API类似`threading`. 其子模块`dummy`实现了与`Multiprocessing.process`相同的API，唯一的区别在于，`dummy`其实只是对`threading`做了一层封装而已. 这给不知道是CPU密集型或者是IO密集型的项目提供了便利，你可以自由地在多进程与多线程之间进行切换而只需更改一行代码。\n\n-------------------\n### 调用error_callback函数\n在python3中， `Multiprocessing`对与`apply_async()`进行了改进，增加了一个默认参数`error_callback=None`，在这里你可以指定相应的错误处理函数，它将在子进程或者子线程运行出现异常是被调用. 与之对应的是`callback=None`参数(Python2也支持)，它将在子进程或者子线程顺利运行之后被调用.\n其原理，在于子线程或者子进程的一个`_success`属性， 其指出了运行状态.\n```python\n    def get(self, timeout=None):\n        self.wait(timeout)\n        if not self.ready():\n            raise TimeoutError\n        if self._success:\n            return self._value\n        else:\n            raise self._value\n\n    def _set(self, i, obj):\n        self._success, self._value = obj\n        if self._callback and self._success:\n            self._callback(self._value)\n        if self._error_callback and not self._success:\n            self._error_callback(self._value)\n        self._event.set()\n        del self._cache[self._job]\n``` \n需要注意的是，`raise self._value`语句抛出的是一个`Exception.AttributeError`,  可以看出只会抛出两种错误，一种是超时错误，一种是`AttributeError`. 而我们能利用的就是`AttributeError`, 在线程或者进程执行过程种出现错误， 我们只需要将合适的错误信息使用`格式化字符串`通过AttributeError传递出去，在`error_callback`去获取这个错误信息，在进行进一步的处理即可， 如果你只需要告知主进程出错了，那么只需要`raise AttributeError`即可. \n\n---------------------\n### 进程间数据共享\n不推荐`pipe`和`queue`，而它们都有可能堵塞进程，所以最好采用其他方式，这里介绍两种，共享内存变量，以及服务进程Manager. 你可以通过使用这两种方式在主进程中检测子线程或者子进程的状态. 至于访问速度，前者与和直接访问内存速度相差无几， 后者速度要低两个数量级\n#### 共享内存变量 Shared  Ctypes Objects\nmulti提供了两种类型，`Multiprocessing.Value`以及`MultiProcessing.Array`, 这两种结果内部实现了Lock，默认是开启的, 因此这时，它们是`process-safe`的. 共享内存变量在父进程中被创建，然后在创建子进程的时候传进去即可. \n\n官方文档示例代码：\n```python\nfrom multiprocessing import Process, Lock\nfrom multiprocessing.sharedctypes import Value, Array\nfrom ctypes import Structure, c_double\n\nclass Point(Structure):\n    _fields_ = [('x', c_double), ('y', c_double)]\n\ndef modify(n, x, s, A):\n    n.value **= 2\n    x.value **= 2\n    s.value = s.value.upper()\n    for a in A:\n        a.x **= 2\n        a.y **= 2\n\nif __name__ == '__main__':\n    lock = Lock()\n\n    n = Value('i', 7)\n    x = Value(c_double, 1.0/3.0, lock=False)\n    s = Array('c', b'hello world', lock=lock)\n    A = Array(Point, [(1.875,-6.25), (-5.75,2.0), (2.375,9.5)], lock=lock)\n\n    p = Process(target=modify, args=(n, x, s, A))\n    p.start()\n    p.join()\n\n    print(\"Ounput:\")\n    print(n.value)\n    print(x.value)\n    print(s.value)\n    print([(a.x, a.y) for a in A])\n```\n> Output:\n> 49\n> 0.1111111111111111\n> HELLO WORLD\n> [(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]\n\n#### 服务进程 Manager\n如果你需要支持更多类型数据的共享呢？ Sever Process Manager 可以完成， 它支持很多数据类型，包括`list`, `dict`, `Namespace`, `Lock`, `RLock`, `Semaphore`, `BoundedSemaphore`, `Condition`, `Event`, `Queue`, `Value`和`Array`. 作为一个独立的服务进程存在，意味着可以远程共享数据，内部实现类似与RPC服务器，每个需要进行读写共享数据的进程，都需要通过proxies来访问服务进程进行操作. 一个Manager对象就控制一个用于管理共享数据的服务进程。由于访问是在网络之上进行的， 因此速度方面没有共享内存快.\nManager的[具体使用方法][1]\n\n--------------------\n### 检查线程退出状态\n由于线程出现异常退出和正常退出时的`exitcode`时不一样的，而线程结束运行后，内存又不会立即被回收，基于此，我们可以通过检查`exitcode`的方式来捕获线程中出现的错误，这种方法来自[PengMeng's Blog][2], 一般地，Python中进程的属性, 或许可以达到和`exitcode`相同的效果. 这里不再深入讨论.\n\n[1]:https://docs.python.org/dev/library/multiprocessing.html#shared-ctypes-objects\n[2]:http://www.jianshu.com/p/e672152d6753\n","slug":"父进程如何捕获子进程的异常？","published":1,"updated":"2017-05-15T12:06:47.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj2qy2r16000gmqjxgmmpvksk","content":"<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>在使用Python开发某些高并发WEB应用后台时，为了提高处理能力，通常会采用多进程或者多线程的方式，但这同时也给异常处理带了一些麻烦。 </p>\n<hr>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>线程是一个轻型实体，只有由很少的支持其独立运行的资源。 对于Python，线程拥有自己独立的栈， 当线程运行出错，线程会直接结束运行，当需要进行错误处理时，一般都会在线程中进行处理，但是如果只能由主进程来处理异常，那么线程要怎么才能将异常通知给主进程呢？<br>对于进程，子进程的产生的异常如何让父进程去处理？</p>\n<hr>\n<h3 id=\"Multiprocessing-Package\"><a href=\"#Multiprocessing-Package\" class=\"headerlink\" title=\"Multiprocessing Package\"></a>Multiprocessing Package</h3><p><code>Multiprocessing</code>是Python的一个多进程库，其实现的API类似<code>threading</code>. 其子模块<code>dummy</code>实现了与<code>Multiprocessing.process</code>相同的API，唯一的区别在于，<code>dummy</code>其实只是对<code>threading</code>做了一层封装而已. 这给不知道是CPU密集型或者是IO密集型的项目提供了便利，你可以自由地在多进程与多线程之间进行切换而只需更改一行代码。</p>\n<hr>\n<h3 id=\"调用error-callback函数\"><a href=\"#调用error-callback函数\" class=\"headerlink\" title=\"调用error_callback函数\"></a>调用error_callback函数</h3><p>在python3中， <code>Multiprocessing</code>对与<code>apply_async()</code>进行了改进，增加了一个默认参数<code>error_callback=None</code>，在这里你可以指定相应的错误处理函数，它将在子进程或者子线程运行出现异常是被调用. 与之对应的是<code>callback=None</code>参数(Python2也支持)，它将在子进程或者子线程顺利运行之后被调用.<br>其原理，在于子线程或者子进程的一个<code>_success</code>属性， 其指出了运行状态.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, timeout=None)</span>:</span></div><div class=\"line\">        self.wait(timeout)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.ready():</div><div class=\"line\">            <span class=\"keyword\">raise</span> TimeoutError</div><div class=\"line\">        <span class=\"keyword\">if</span> self._success:</div><div class=\"line\">            <span class=\"keyword\">return</span> self._value</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> self._value</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_set</span><span class=\"params\">(self, i, obj)</span>:</span></div><div class=\"line\">        self._success, self._value = obj</div><div class=\"line\">        <span class=\"keyword\">if</span> self._callback <span class=\"keyword\">and</span> self._success:</div><div class=\"line\">            self._callback(self._value)</div><div class=\"line\">        <span class=\"keyword\">if</span> self._error_callback <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> self._success:</div><div class=\"line\">            self._error_callback(self._value)</div><div class=\"line\">        self._event.set()</div><div class=\"line\">        <span class=\"keyword\">del</span> self._cache[self._job]</div><div class=\"line\">``` </div><div class=\"line\">需要注意的是，`<span class=\"keyword\">raise</span> self._value`语句抛出的是一个`Exception.AttributeError`,  可以看出只会抛出两种错误，一种是超时错误，一种是`AttributeError`. 而我们能利用的就是`AttributeError`, 在线程或者进程执行过程种出现错误， 我们只需要将合适的错误信息使用`格式化字符串`通过AttributeError传递出去，在`error_callback`去获取这个错误信息，在进行进一步的处理即可， 如果你只需要告知主进程出错了，那么只需要`<span class=\"keyword\">raise</span> AttributeError`即可. </div><div class=\"line\"></div><div class=\"line\">---------------------</div><div class=\"line\"><span class=\"comment\">### 进程间数据共享</span></div><div class=\"line\">不推荐`pipe`和`queue`，而它们都有可能堵塞进程，所以最好采用其他方式，这里介绍两种，共享内存变量，以及服务进程Manager. 你可以通过使用这两种方式在主进程中检测子线程或者子进程的状态. 至于访问速度，前者与和直接访问内存速度相差无几， 后者速度要低两个数量级</div><div class=\"line\"><span class=\"comment\">#### 共享内存变量 Shared  Ctypes Objects</span></div><div class=\"line\">multi提供了两种类型，`Multiprocessing.Value`以及`MultiProcessing.Array`, 这两种结果内部实现了Lock，默认是开启的, 因此这时，它们是`process-safe`的. 共享内存变量在父进程中被创建，然后在创建子进程的时候传进去即可. </div><div class=\"line\"></div><div class=\"line\">官方文档示例代码：</div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Lock</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.sharedctypes <span class=\"keyword\">import</span> Value, Array</div><div class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> Structure, c_double</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span><span class=\"params\">(Structure)</span>:</span></div><div class=\"line\">    _fields_ = [(<span class=\"string\">'x'</span>, c_double), (<span class=\"string\">'y'</span>, c_double)]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">modify</span><span class=\"params\">(n, x, s, A)</span>:</span></div><div class=\"line\">    n.value **= <span class=\"number\">2</span></div><div class=\"line\">    x.value **= <span class=\"number\">2</span></div><div class=\"line\">    s.value = s.value.upper()</div><div class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</div><div class=\"line\">        a.x **= <span class=\"number\">2</span></div><div class=\"line\">        a.y **= <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    lock = Lock()</div><div class=\"line\"></div><div class=\"line\">    n = Value(<span class=\"string\">'i'</span>, <span class=\"number\">7</span>)</div><div class=\"line\">    x = Value(c_double, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>, lock=<span class=\"keyword\">False</span>)</div><div class=\"line\">    s = Array(<span class=\"string\">'c'</span>, <span class=\"string\">b'hello world'</span>, lock=lock)</div><div class=\"line\">    A = Array(Point, [(<span class=\"number\">1.875</span>,<span class=\"number\">-6.25</span>), (<span class=\"number\">-5.75</span>,<span class=\"number\">2.0</span>), (<span class=\"number\">2.375</span>,<span class=\"number\">9.5</span>)], lock=lock)</div><div class=\"line\"></div><div class=\"line\">    p = Process(target=modify, args=(n, x, s, A))</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\"></div><div class=\"line\">    print(<span class=\"string\">\"Ounput:\"</span>)</div><div class=\"line\">    print(n.value)</div><div class=\"line\">    print(x.value)</div><div class=\"line\">    print(s.value)</div><div class=\"line\">    print([(a.x, a.y) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A])</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Output:<br>49<br>0.1111111111111111<br>HELLO WORLD<br>[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]</p>\n</blockquote>\n<h4 id=\"服务进程-Manager\"><a href=\"#服务进程-Manager\" class=\"headerlink\" title=\"服务进程 Manager\"></a>服务进程 Manager</h4><p>如果你需要支持更多类型数据的共享呢？ Sever Process Manager 可以完成， 它支持很多数据类型，包括<code>list</code>, <code>dict</code>, <code>Namespace</code>, <code>Lock</code>, <code>RLock</code>, <code>Semaphore</code>, <code>BoundedSemaphore</code>, <code>Condition</code>, <code>Event</code>, <code>Queue</code>, <code>Value</code>和<code>Array</code>. 作为一个独立的服务进程存在，意味着可以远程共享数据，内部实现类似与RPC服务器，每个需要进行读写共享数据的进程，都需要通过proxies来访问服务进程进行操作. 一个Manager对象就控制一个用于管理共享数据的服务进程。由于访问是在网络之上进行的， 因此速度方面没有共享内存快.<br>Manager的<a href=\"https://docs.python.org/dev/library/multiprocessing.html#shared-ctypes-objects\" target=\"_blank\" rel=\"external\">具体使用方法</a></p>\n<hr>\n<h3 id=\"检查线程退出状态\"><a href=\"#检查线程退出状态\" class=\"headerlink\" title=\"检查线程退出状态\"></a>检查线程退出状态</h3><p>由于线程出现异常退出和正常退出时的<code>exitcode</code>时不一样的，而线程结束运行后，内存又不会立即被回收，基于此，我们可以通过检查<code>exitcode</code>的方式来捕获线程中出现的错误，这种方法来自<a href=\"http://www.jianshu.com/p/e672152d6753\" target=\"_blank\" rel=\"external\">PengMeng’s Blog</a>, 一般地，Python中进程的属性, 或许可以达到和<code>exitcode</code>相同的效果. 这里不再深入讨论.</p>\n","site":{"data":{"projects":[{"name":"Allegro","url":"https://github.com/Alecyrus/Allegro","desc":"The more efficient python backend integration framework"},{"name":"Ares","url":"https://github.com/Alecyrus/Ares","desc":"A private cloud backend based on OpenStack Mitaka."},{"name":"SpringX","url":"https://github.com/Alecyrus/SpringX","desc":"The web front-end for the simple private cloud."},{"name":"Compiler","url":"https://github.com/Alecyrus/Compiler","desc":"A simple C compiler."}]}},"excerpt":"","more":"<h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>在使用Python开发某些高并发WEB应用后台时，为了提高处理能力，通常会采用多进程或者多线程的方式，但这同时也给异常处理带了一些麻烦。 </p>\n<hr>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>线程是一个轻型实体，只有由很少的支持其独立运行的资源。 对于Python，线程拥有自己独立的栈， 当线程运行出错，线程会直接结束运行，当需要进行错误处理时，一般都会在线程中进行处理，但是如果只能由主进程来处理异常，那么线程要怎么才能将异常通知给主进程呢？<br>对于进程，子进程的产生的异常如何让父进程去处理？</p>\n<hr>\n<h3 id=\"Multiprocessing-Package\"><a href=\"#Multiprocessing-Package\" class=\"headerlink\" title=\"Multiprocessing Package\"></a>Multiprocessing Package</h3><p><code>Multiprocessing</code>是Python的一个多进程库，其实现的API类似<code>threading</code>. 其子模块<code>dummy</code>实现了与<code>Multiprocessing.process</code>相同的API，唯一的区别在于，<code>dummy</code>其实只是对<code>threading</code>做了一层封装而已. 这给不知道是CPU密集型或者是IO密集型的项目提供了便利，你可以自由地在多进程与多线程之间进行切换而只需更改一行代码。</p>\n<hr>\n<h3 id=\"调用error-callback函数\"><a href=\"#调用error-callback函数\" class=\"headerlink\" title=\"调用error_callback函数\"></a>调用error_callback函数</h3><p>在python3中， <code>Multiprocessing</code>对与<code>apply_async()</code>进行了改进，增加了一个默认参数<code>error_callback=None</code>，在这里你可以指定相应的错误处理函数，它将在子进程或者子线程运行出现异常是被调用. 与之对应的是<code>callback=None</code>参数(Python2也支持)，它将在子进程或者子线程顺利运行之后被调用.<br>其原理，在于子线程或者子进程的一个<code>_success</code>属性， 其指出了运行状态.<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, timeout=None)</span>:</span></div><div class=\"line\">        self.wait(timeout)</div><div class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.ready():</div><div class=\"line\">            <span class=\"keyword\">raise</span> TimeoutError</div><div class=\"line\">        <span class=\"keyword\">if</span> self._success:</div><div class=\"line\">            <span class=\"keyword\">return</span> self._value</div><div class=\"line\">        <span class=\"keyword\">else</span>:</div><div class=\"line\">            <span class=\"keyword\">raise</span> self._value</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_set</span><span class=\"params\">(self, i, obj)</span>:</span></div><div class=\"line\">        self._success, self._value = obj</div><div class=\"line\">        <span class=\"keyword\">if</span> self._callback <span class=\"keyword\">and</span> self._success:</div><div class=\"line\">            self._callback(self._value)</div><div class=\"line\">        <span class=\"keyword\">if</span> self._error_callback <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> self._success:</div><div class=\"line\">            self._error_callback(self._value)</div><div class=\"line\">        self._event.set()</div><div class=\"line\">        <span class=\"keyword\">del</span> self._cache[self._job]</div><div class=\"line\">``` </div><div class=\"line\">需要注意的是，`<span class=\"keyword\">raise</span> self._value`语句抛出的是一个`Exception.AttributeError`,  可以看出只会抛出两种错误，一种是超时错误，一种是`AttributeError`. 而我们能利用的就是`AttributeError`, 在线程或者进程执行过程种出现错误， 我们只需要将合适的错误信息使用`格式化字符串`通过AttributeError传递出去，在`error_callback`去获取这个错误信息，在进行进一步的处理即可， 如果你只需要告知主进程出错了，那么只需要`<span class=\"keyword\">raise</span> AttributeError`即可. </div><div class=\"line\"></div><div class=\"line\">---------------------</div><div class=\"line\"><span class=\"comment\">### 进程间数据共享</span></div><div class=\"line\">不推荐`pipe`和`queue`，而它们都有可能堵塞进程，所以最好采用其他方式，这里介绍两种，共享内存变量，以及服务进程Manager. 你可以通过使用这两种方式在主进程中检测子线程或者子进程的状态. 至于访问速度，前者与和直接访问内存速度相差无几， 后者速度要低两个数量级</div><div class=\"line\"><span class=\"comment\">#### 共享内存变量 Shared  Ctypes Objects</span></div><div class=\"line\">multi提供了两种类型，`Multiprocessing.Value`以及`MultiProcessing.Array`, 这两种结果内部实现了Lock，默认是开启的, 因此这时，它们是`process-safe`的. 共享内存变量在父进程中被创建，然后在创建子进程的时候传进去即可. </div><div class=\"line\"></div><div class=\"line\">官方文档示例代码：</div><div class=\"line\">```python</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process, Lock</div><div class=\"line\"><span class=\"keyword\">from</span> multiprocessing.sharedctypes <span class=\"keyword\">import</span> Value, Array</div><div class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> Structure, c_double</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span><span class=\"params\">(Structure)</span>:</span></div><div class=\"line\">    _fields_ = [(<span class=\"string\">'x'</span>, c_double), (<span class=\"string\">'y'</span>, c_double)]</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">modify</span><span class=\"params\">(n, x, s, A)</span>:</span></div><div class=\"line\">    n.value **= <span class=\"number\">2</span></div><div class=\"line\">    x.value **= <span class=\"number\">2</span></div><div class=\"line\">    s.value = s.value.upper()</div><div class=\"line\">    <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A:</div><div class=\"line\">        a.x **= <span class=\"number\">2</span></div><div class=\"line\">        a.y **= <span class=\"number\">2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</div><div class=\"line\">    lock = Lock()</div><div class=\"line\"></div><div class=\"line\">    n = Value(<span class=\"string\">'i'</span>, <span class=\"number\">7</span>)</div><div class=\"line\">    x = Value(c_double, <span class=\"number\">1.0</span>/<span class=\"number\">3.0</span>, lock=<span class=\"keyword\">False</span>)</div><div class=\"line\">    s = Array(<span class=\"string\">'c'</span>, <span class=\"string\">b'hello world'</span>, lock=lock)</div><div class=\"line\">    A = Array(Point, [(<span class=\"number\">1.875</span>,<span class=\"number\">-6.25</span>), (<span class=\"number\">-5.75</span>,<span class=\"number\">2.0</span>), (<span class=\"number\">2.375</span>,<span class=\"number\">9.5</span>)], lock=lock)</div><div class=\"line\"></div><div class=\"line\">    p = Process(target=modify, args=(n, x, s, A))</div><div class=\"line\">    p.start()</div><div class=\"line\">    p.join()</div><div class=\"line\"></div><div class=\"line\">    print(<span class=\"string\">\"Ounput:\"</span>)</div><div class=\"line\">    print(n.value)</div><div class=\"line\">    print(x.value)</div><div class=\"line\">    print(s.value)</div><div class=\"line\">    print([(a.x, a.y) <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> A])</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Output:<br>49<br>0.1111111111111111<br>HELLO WORLD<br>[(3.515625, 39.0625), (33.0625, 4.0), (5.640625, 90.25)]</p>\n</blockquote>\n<h4 id=\"服务进程-Manager\"><a href=\"#服务进程-Manager\" class=\"headerlink\" title=\"服务进程 Manager\"></a>服务进程 Manager</h4><p>如果你需要支持更多类型数据的共享呢？ Sever Process Manager 可以完成， 它支持很多数据类型，包括<code>list</code>, <code>dict</code>, <code>Namespace</code>, <code>Lock</code>, <code>RLock</code>, <code>Semaphore</code>, <code>BoundedSemaphore</code>, <code>Condition</code>, <code>Event</code>, <code>Queue</code>, <code>Value</code>和<code>Array</code>. 作为一个独立的服务进程存在，意味着可以远程共享数据，内部实现类似与RPC服务器，每个需要进行读写共享数据的进程，都需要通过proxies来访问服务进程进行操作. 一个Manager对象就控制一个用于管理共享数据的服务进程。由于访问是在网络之上进行的， 因此速度方面没有共享内存快.<br>Manager的<a href=\"https://docs.python.org/dev/library/multiprocessing.html#shared-ctypes-objects\" target=\"_blank\" rel=\"external\">具体使用方法</a></p>\n<hr>\n<h3 id=\"检查线程退出状态\"><a href=\"#检查线程退出状态\" class=\"headerlink\" title=\"检查线程退出状态\"></a>检查线程退出状态</h3><p>由于线程出现异常退出和正常退出时的<code>exitcode</code>时不一样的，而线程结束运行后，内存又不会立即被回收，基于此，我们可以通过检查<code>exitcode</code>的方式来捕获线程中出现的错误，这种方法来自<a href=\"http://www.jianshu.com/p/e672152d6753\" target=\"_blank\" rel=\"external\">PengMeng’s Blog</a>, 一般地，Python中进程的属性, 或许可以达到和<code>exitcode</code>相同的效果. 这里不再深入讨论.</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj2qy2r010000mqjxfju6ttgb","tag_id":"cj2qy2r0d0002mqjx6exjtb6k","_id":"cj2qy2r0p0007mqjxt3791m8q"},{"post_id":"cj2qy2r080001mqjx6di02rf7","tag_id":"cj2qy2r0o0006mqjxc9wakpyx","_id":"cj2qy2r11000cmqjxqch7zxgn"},{"post_id":"cj2qy2r0z000bmqjxb4qd6q2z","tag_id":"cj2qy2r0o0006mqjxc9wakpyx","_id":"cj2qy2r15000fmqjx6x95vo8i"},{"post_id":"cj2qy2r0g0003mqjx4axjc87a","tag_id":"cj2qy2r0y000amqjx24se528u","_id":"cj2qy2r1a000hmqjxxm1p30q8"},{"post_id":"cj2qy2r14000dmqjxx9ildlkk","tag_id":"cj2qy2r0y000amqjx24se528u","_id":"cj2qy2r1c000imqjxn2g68x8y"},{"post_id":"cj2qy2r0k0004mqjxgiv46x62","tag_id":"cj2qy2r15000emqjxza899mz2","_id":"cj2qy2r1c000kmqjxkgzknrg4"},{"post_id":"cj2qy2r0m0005mqjx7hspjri1","tag_id":"cj2qy2r1c000jmqjxhbhacqfx","_id":"cj2qy2r1e000mmqjxagjpjr3t"},{"post_id":"cj2qy2r0p0008mqjxo2icr4re","tag_id":"cj2qy2r0y000amqjx24se528u","_id":"cj2qy2r1f000omqjx0gt6z5e1"},{"post_id":"cj2qy2r0x0009mqjxdc4hzd25","tag_id":"cj2qy2r1f000nmqjx1oq2w3w6","_id":"cj2qy2r1j000rmqjxizqa487x"},{"post_id":"cj2qy2r0x0009mqjxdc4hzd25","tag_id":"cj2qy2r1h000pmqjxz4cz99ta","_id":"cj2qy2r1j000smqjxiy598dwt"},{"post_id":"cj2qy2r16000gmqjxgmmpvksk","tag_id":"cj2qy2r1i000qmqjxfwl6evd8","_id":"cj2qy2r1j000tmqjxp2ubkkwz"}],"Tag":[{"name":"AMQP","_id":"cj2qy2r0d0002mqjx6exjtb6k"},{"name":"Archipel","_id":"cj2qy2r0o0006mqjxc9wakpyx"},{"name":"OpenStack","_id":"cj2qy2r0y000amqjx24se528u"},{"name":"RPC","_id":"cj2qy2r15000emqjxza899mz2"},{"name":"RabbitMQ","_id":"cj2qy2r1c000jmqjxhbhacqfx"},{"name":"Linux","_id":"cj2qy2r1f000nmqjx1oq2w3w6"},{"name":"GuestFish","_id":"cj2qy2r1h000pmqjxz4cz99ta"},{"name":"Python","_id":"cj2qy2r1i000qmqjxfwl6evd8"}]}}